<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.FakePrelude</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-FakePrelude.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.3.0.1: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Data.HList.FakePrelude</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">A heterogeneous apply operator
</a><ul><li><a href="#g:2">Simple useful instances of Apply
</a></li></ul></li><li><a href="#g:3">Proxy
</a></li><li><a href="#g:4">Booleans
</a><ul><li><a href="#g:5">Value-level proxies
</a></li><li><a href="#g:6">Conjunction
</a></li><li><a href="#g:7">Disjunction
</a></li><li><a href="#g:8">Boolean equivalence
</a></li></ul></li><li><a href="#g:9">Naturals
</a></li><li><a href="#g:10">Maybies
</a></li><li><a href="#g:11">Polykinded Equality for types
</a></li><li><a href="#g:12">Staged equality
</a></li><li><a href="#g:13">Type-safe cast -- no longer need. We use a a ~ b
</a></li><li><a href="#g:14">Error messages
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The HList library
</p><p>(C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
</p><p>Some very basic technology for faking dependent types in Haskell.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span>  <a href="#t:Apply">Apply</a> f a  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:ApplyR">ApplyR</a> f a :: *</li><li><a href="#v:apply">apply</a> :: f -&gt; a -&gt; <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> f a</li></ul></li><li class="src short"><span class="keyword">class</span>  <a href="#t:ApplyAB">ApplyAB</a> f a b  <span class="keyword">where</span><ul class="subs"><li><a href="#v:applyAB">applyAB</a> :: f -&gt; a -&gt; b</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Fun">Fun</a> cxt getb = <a href="#v:Fun">Fun</a> (<span class="keyword">forall</span> a. <a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> cxt a =&gt; a -&gt; <a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> getb a)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Fun-39-">Fun'</a> cxt geta = <a href="#v:Fun-39-">Fun'</a> (<span class="keyword">forall</span> b. <a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> cxt b =&gt; <a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> geta b -&gt; b)</li><li class="src short"><span class="keyword">type family</span> <a href="#t:FunApp">FunApp</a> fns a </li><li class="src short"><span class="keyword">type family</span> <a href="#t:FunCxt">FunCxt</a> cxts a :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:HPrint">HPrint</a>  = <a href="#v:HPrint">HPrint</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:HRead">HRead</a>  = <a href="#v:HRead">HRead</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:HShow">HShow</a>  = <a href="#v:HShow">HShow</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:HComp">HComp</a> g f = <a href="#v:HComp">HComp</a> g f</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Comp">Comp</a>  = <a href="#v:Comp">Comp</a></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:HSeq">HSeq</a> x = <a href="#v:HSeq">HSeq</a> x</li><li class="src short"><span class="keyword">data</span>  <a href="#t:HFlip">HFlip</a>  = <a href="#v:HFlip">HFlip</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Label">Label</a> l = <a href="#v:Label">Label</a></li><li class="src short"><a href="#v:labelToProxy">labelToProxy</a> ::  <a href="Data-HList-FakePrelude.html#t:Label">Label</a> l -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> l</li><li class="src short"><span class="keyword">class</span>  <a href="#t:ShowLabel">ShowLabel</a> l  <span class="keyword">where</span><ul class="subs"><li><a href="#v:showLabel">showLabel</a> :: <a href="Data-HList-FakePrelude.html#t:Label">Label</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></li></ul></li><li class="src short"><a href="#v:hTrue">hTrue</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></li><li class="src short"><a href="#v:hFalse">hFalse</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HAnd">HAnd</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:hAnd">hAnd</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t1 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t2 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#t:HAnd">HAnd</a> t1 t2)</li><li class="src short"><span class="keyword">type family</span> <a href="#t:HOr">HOr</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:hOr">hOr</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t1 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t2 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#t:HOr">HOr</a> t1 t2)</li><li class="src short"><span class="keyword">class</span>  <a href="#t:HCond">HCond</a> t x y z | t x y -&gt; z <span class="keyword">where</span><ul class="subs"><li><a href="#v:hCond">hCond</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t -&gt; x -&gt; y -&gt; z</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HBoolEQ">HBoolEQ</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:HNat">HNat</a> <ul class="subs"><li>= <a href="#v:HZero">HZero</a>  </li><li>| <a href="#v:HSucc">HSucc</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a>  </li></ul></li><li class="src short"><a href="#v:hZero">hZero</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a></li><li class="src short"><a href="#v:hSucc">hSucc</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (n :: <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a>) -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)</li><li class="src short"><a href="#v:hPred">hPred</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> n</li><li class="src short"><span class="keyword">class</span>  <a href="#t:HNat2Integral">HNat2Integral</a> n  <span class="keyword">where</span><ul class="subs"><li><a href="#v:hNat2Integral">hNat2Integral</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Integral">Integral</a> i =&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> n -&gt; i</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HNatEq">HNatEq</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HLt">HLt</a> x y :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:hLt">hLt</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> x -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> y -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#t:HLt">HLt</a> x y)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:HNothing">HNothing</a>  = <a href="#v:HNothing">HNothing</a></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:HJust">HJust</a> x = <a href="#v:HJust">HJust</a> x</li><li class="src short"><span class="keyword">class</span>  <a href="#t:HEq">HEq</a> x y b | x y -&gt; b</li><li class="src short"><a href="#v:hEq">hEq</a> :: <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> x y b =&gt; x -&gt; y -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> b</li><li class="src short"><span class="keyword">class</span>  <a href="#t:Fail">Fail</a> x </li><li class="src short">module <a href="Data-HList-FakePrelude-Proxy.html">Data.HList.FakePrelude.Proxy</a></li></ul></div><div id="interface"><h1 id="g:1">A heterogeneous apply operator
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Apply" class="def">Apply</a> f a  <span class="keyword">where</span></p><div class="doc"><p>simpler/weaker version where type information only propagates forward
 with this one. <code>app</code> defined below, is more complicated / verbose to define,
 but it offers better type inference. Most uses have been converted to
 <code>app</code>, so there is not much that can be done with <code><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a></code>.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:ApplyR" class="def">ApplyR</a> f a :: *</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:apply" class="def">apply</a> :: f -&gt; a -&gt; <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> f a</p></div><div class="subs instances"><p id="control.i:Apply" class="caption collapser" onclick="toggleSection('i:Apply')">Instances</p><div id="section.i:Apply" class="show"><table><tr><td class="src"><a href="Data-HList-HArray.html#t:HLookupByHNat">HLookupByHNat</a> n l =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHLookupByHNat">FHLookupByHNat</a> l) (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> l, <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)) =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * ch (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Data-HList-FakePrelude.html#t:HBoolEQ">HBoolEQ</a> sel (<a href="Data-HList-HArray.html#t:KMember">KMember</a> n ns))), <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (ch, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)) =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *), n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="doc"><p>Polymorphic functions are not first-class in haskell. One solution is to
 write an instance of <code><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a></code> for a data type that takes the place of
 the original function. In other words,
</p><pre> data Fn = Fn
 instance ApplyAB Fn a b where applyAB Fn a = actual_fn a
</pre><p>Normally you would have been able to pass around the definition actual_fn.
</p><dl><dt><code>Type inference / Local functional dependencies</code></dt><dd>
</dd></dl><p>Note that <code>class ApplyAB</code> has three parameters and no functional dependencies.
 Instances should be written in the style:
</p><pre> instance (int ~ Int, double ~ Double) =&gt; ApplyAB Fn int double
  where applyAB _ = fromIntegral
</pre><p>rather than the more natural
</p><pre> instance ApplyAB Fn Int Double
</pre><p>The first instance allows types to be inferred as if we had
 <code>class ApplyAB a b c | a -&gt; b c</code>, while the second instance
 only matches if ghc already knows that it needs
 <code>ApplyAB Fn Int Double</code>. Additional explanation can be found
 in <a href="http://okmij.org/ftp/Haskell/typecast.html#local-fd">local functional dependencies</a>
</p></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:ApplyAB" class="def">ApplyAB</a> f a b  <span class="keyword">where</span></p><div class="doc"><p>No constraints on result and argument types
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:applyAB" class="def">applyAB</a> :: f -&gt; a -&gt; b</p></div><div class="subs instances"><p id="control.i:ApplyAB" class="caption collapser" onclick="toggleSection('i:ApplyAB')">Instances</p><div id="section.i:ApplyAB" class="show"><table><tr><td class="src">(~ * f1 (a -&gt; b -&gt; c), ~ * f2 (b -&gt; a -&gt; c)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HFlip">HFlip</a> f1 f2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * y y', ~ * fg (x -&gt; y, y' -&gt; z), ~ * r (x -&gt; z)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:Comp">Comp</a> fg r</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> string, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HShow">HShow</a> a string</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> string, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HRead">HRead</a> string a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * io (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:IO">IO</a> ()), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> x) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HPrint">HPrint</a> x io</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">~ * hJustA (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HList.html#t:HFromJust">HFromJust</a> hJustA a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * x (e, <a href="Data-HList-HList.html#t:HList">HList</a> l), ~ * y (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l))) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HList.html#t:FHCons">FHCons</a> x y</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-HZip.html#t:HZip3">HZip3</a> a b c, ~ * x (<a href="Data-HList-HList.html#t:HList">HList</a> a, <a href="Data-HList-HList.html#t:HList">HList</a> b), ~ * y (<a href="Data-HList-HList.html#t:HList">HList</a> c)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HZip.html#t:HZipF">HZipF</a> x y</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * (<a href="Data-HList-Record.html#t:LVPair">LVPair</a> k l (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> * t)) a, ~ * b (<a href="Data-HList-Record.html#t:LVPair">LVPair</a> k l (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> t))) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-Variant.html#t:HMaybeF">HMaybeF</a> a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">~ * e' e =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HList.html#t:HRmTag">HRmTag</a> (e, t) e'</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">~ * hJustA (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> t) a hJustA</td><td class="doc"><p><code>HJust ()</code> is a placeholder for a function that applies the <code><a href="Data-HList-FakePrelude.html#t:HJust">HJust</a></code> constructor
</p></td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f x fx, ~ * fx (m ()), ~ * pair (x, m ()), <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f x (m ())) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:HSeq">HSeq</a> f) pair fx</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">~ * et (e, t) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:HAddTag">HAddTag</a> t) e et</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * l [e'], <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f e e', ~ * el (e, l)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:Mapcar">Mapcar</a> f) el l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f (x, y) z, ~ * mz (m z), ~ * mxy (m x, m y), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:LiftA2">LiftA2</a> f) mxy mz</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HMapCxt">HMapCxt</a> f as bs as' bs' =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:HMap">HMap</a> f) as bs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Data.html#t:Data">Data</a> b, ~ * x (t, c (b -&gt; r)), ~ * y (c r)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-Data.html#t:GunfoldK">GunfoldK</a> c) x y</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Data.html#t:Data">Data</a> d, ~ * (c (d -&gt; b), d) x, ~ * (c b) y) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-Data.html#t:GfoldlK">GfoldlK</a> c) x y</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f e e' =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:MapCar">MapCar</a> f) (e, <a href="Data-HList-HList.html#t:HList">HList</a> l) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e' l))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * x' x, ~ * y' y) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (x' -&gt; y') x y</td><td class="doc"><p>note this function will only be available at a single type
 (that is, <code>hMap succ</code> will only work on <code>HList</code> that contain
 only one type)
</p></td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f a b, <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> g b c) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:HComp">HComp</a> g f) a c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> k cxt b, ~ * (<a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> k1 geta b) a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:Fun-39-">Fun'</a> k k1 cxt geta) a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> k cxt a, ~ * (<a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> k1 getb a) b) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:Fun">Fun</a> k k1 cxt getb) a b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="doc"><p><code><a href="Data-HList-FakePrelude.html#t:Fun">Fun</a></code> can be used instead of writing a new instance of
 <code><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a></code>. Refer to the definition/source for the the most
 concise explanation. A more wordy explanation is given below:
</p><p>A type signature needs to be provided on <code><a href="Data-HList-FakePrelude.html#t:Fun">Fun</a></code> to make it work.
 Depending on the kind of the parameters to <code><a href="Data-HList-FakePrelude.html#t:Fun">Fun</a></code>, a number of
 different results happen.
</p><dl><dt><code>ex1</code></dt><dd>
</dd></dl><p>A list of kind <code>[* -&gt; Constraint]</code> produces those
 constraints on the argument type:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDataKinds
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let plus1 = Fun (\x -&gt; if x &lt; 5 then x+1 else 5) :: Fun '[Num, Ord] '()
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t applyAB plus1
</code></strong>applyAB plus1 :: (Num a, Ord a) =&gt; a -&gt; a
</pre><p>Also note the use of <code>'()</code> to signal that the result
 type is the same as the argument type.
</p><p>A single constraint can also be supplied:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let succ1 = Fun succ :: Fun Enum '()
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t applyAB succ1
</code></strong>applyAB succ1 :: Enum a =&gt; a -&gt; a
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let just = Fun Just :: Fun '[] Maybe
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t applyAB just
</code></strong>applyAB just :: a -&gt; Maybe a
</pre></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Fun" class="def">Fun</a> cxt getb </p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fun" class="def">Fun</a> (<span class="keyword">forall</span> a. <a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> cxt a =&gt; a -&gt; <a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> getb a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Fun" class="caption collapser" onclick="toggleSection('i:Fun')">Instances</p><div id="section.i:Fun" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> k cxt a, ~ * (<a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> k1 getb a) b) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:Fun">Fun</a> k k1 cxt getb) a b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Fun-39-" class="def">Fun'</a> cxt geta </p><div class="doc"><p>see <code><a href="Data-HList-FakePrelude.html#t:Fun">Fun</a></code>. The only difference here is that the argument
type is calculated from the result type.
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let rd = Fun' read :: Fun' Read String
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t applyAB rd
</code></strong>applyAB rd :: Read b =&gt; [Char] -&gt; b
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fromJust' = Fun' (\(Just a) -&gt; a) :: Fun' '[] Maybe
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t applyAB fromJust'
</code></strong>applyAB fromJust' :: Maybe b -&gt; b
</pre><p>Note this use of Fun' means we don't have to get the b out of <code>Maybe b</code>,
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fun-39-" class="def">Fun'</a> (<span class="keyword">forall</span> b. <a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> cxt b =&gt; <a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> geta b -&gt; b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Fun-39-" class="caption collapser" onclick="toggleSection('i:Fun-39-')">Instances</p><div id="section.i:Fun-39-" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:FunCxt">FunCxt</a> k cxt b, ~ * (<a href="Data-HList-FakePrelude.html#t:FunApp">FunApp</a> k1 geta b) a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:Fun-39-">Fun'</a> k k1 cxt geta) a b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:FunApp" class="def">FunApp</a> fns a </p></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:FunCxt" class="def">FunCxt</a> cxts a :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></p></div><h2 id="g:2">Simple useful instances of Apply
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HPrint" class="def">HPrint</a>  </p><div class="doc"><p>print. An alternative implementation could be:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let hPrint = Fun print :: Fun Show (IO ())
</code></strong></pre><p>This produces:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t applyAB hPrint
</code></strong>applyAB hPrint :: Show a =&gt; a -&gt; IO ()
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HPrint" class="def">HPrint</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HPrint" class="caption collapser" onclick="toggleSection('i:HPrint')">Instances</p><div id="section.i:HPrint" class="show"><table><tr><td class="src">(~ * io (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:IO">IO</a> ()), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> x) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HPrint">HPrint</a> x io</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HRead" class="def">HRead</a>  </p><div class="doc"><p>read
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>applyAB HRead &quot;5.0&quot; :: Double
</code></strong>5.0
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HRead" class="def">HRead</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HRead" class="caption collapser" onclick="toggleSection('i:HRead')">Instances</p><div id="section.i:HRead" class="show"><table><tr><td class="src">(~ * <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> string, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HRead">HRead</a> string a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HShow" class="def">HShow</a>  </p><div class="doc"><p>show
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HShow" class="def">HShow</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HShow" class="caption collapser" onclick="toggleSection('i:HShow')">Instances</p><div id="section.i:HShow" class="show"><table><tr><td class="src">(~ * <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> string, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HShow">HShow</a> a string</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HComp" class="def">HComp</a> g f </p><div class="doc"><p>Compose two instances of <code><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a></code>
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>applyAB (HComp HRead HShow) (5::Double) :: Double
</code></strong>5.0
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HComp" class="def">HComp</a> g f</td><td class="doc"><pre>g . f</pre></td></tr></table></div><div class="subs instances"><p id="control.i:HComp" class="caption collapser" onclick="toggleSection('i:HComp')">Instances</p><div id="section.i:HComp" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f a b, <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> g b c) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:HComp">HComp</a> g f) a c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Comp" class="def">Comp</a>  </p><div class="doc"><p><code>app Comp (f,g) = g . f</code>. Works like:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>applyAB Comp (succ, pred) 'a'
</code></strong>'a'
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>applyAB Comp (toEnum :: Int -&gt; Char, fromEnum) 10
</code></strong>10
</pre><p>Note that defaulting will sometimes give you the wrong thing
</p><pre> used to work (with associated types calculating result/argument types)
 &gt;&gt;&gt; applyAB Comp (fromEnum, toEnum) 'a'
 *** Exception: Prelude.Enum.().toEnum: bad argument
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Comp" class="def">Comp</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Comp" class="caption collapser" onclick="toggleSection('i:Comp')">Instances</p><div id="section.i:Comp" class="show"><table><tr><td class="src">(~ * y y', ~ * fg (x -&gt; y, y' -&gt; z), ~ * r (x -&gt; z)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:Comp">Comp</a> fg r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:HSeq" class="def">HSeq</a> x </p><div class="doc"><p>((a,b) -&gt; f a &gt;&gt; b)
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HSeq" class="def">HSeq</a> x</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HSeq" class="caption collapser" onclick="toggleSection('i:HSeq')">Instances</p><div id="section.i:HSeq" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f x fx, ~ * fx (m ()), ~ * pair (x, m ()), <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f x (m ())) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:HSeq">HSeq</a> f) pair fx</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HFlip" class="def">HFlip</a>  </p><div class="doc"><p><code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#v:flip">flip</a></code>
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HFlip" class="def">HFlip</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HFlip" class="caption collapser" onclick="toggleSection('i:HFlip')">Instances</p><div id="section.i:HFlip" class="show"><table><tr><td class="src">(~ * f1 (a -&gt; b -&gt; c), ~ * f2 (b -&gt; a -&gt; c)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-FakePrelude.html#t:HFlip">HFlip</a> f1 f2</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Proxy
</h1><div class="doc"><p>see <a href="Data-HList-Proxy.html">Data.HList.Proxy</a>
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Label" class="def">Label</a> l </p><div class="doc"><p>A special <code><a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a></code> for record labels, polykinded
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Label" class="def">Label</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Label" class="caption collapser" onclick="toggleSection('i:Label')">Instances</p><div id="section.i:Label" class="show"><table><tr><td class="src">~ k x x' =&gt; <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> * k (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> k x) x'</td><td class="doc"><p>for <a href="Data-HList-Label6.html">Data.HList.Label6</a> labels
</p></td></tr><tr><td class="src"><a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> * (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> s -&gt; a -&gt; b) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc"><p>labels that impose no restriction on the type of the (single) argument
 which follows
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (_ :: Label &quot;a&quot;) (a :: Int) () = a+1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (Label :: Label &quot;a&quot;) 5 ()
</code></strong>6
</pre></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> desc =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> k * x ns desc))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:labelToProxy" class="def">labelToProxy</a> ::  <a href="Data-HList-FakePrelude.html#t:Label">Label</a> l -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> l</p></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:ShowLabel" class="def">ShowLabel</a> l  <span class="keyword">where</span></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:showLabel" class="def">showLabel</a> :: <a href="Data-HList-FakePrelude.html#t:Label">Label</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></p></div><div class="subs instances"><p id="control.i:ShowLabel" class="caption collapser" onclick="toggleSection('i:ShowLabel')">Instances</p><div id="section.i:ShowLabel" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:SingI">SingI</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> x =&gt; <a href="Data-HList-FakePrelude.html#t:ShowLabel">ShowLabel</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> x</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> desc =&gt; <a href="Data-HList-FakePrelude.html#t:ShowLabel">ShowLabel</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> k * x ns desc)</td><td class="doc"><p>Equality on labels (descriptions are ignored)
 Use generic instance
</p><p>Show label
</p></td></tr></table></div></div></div><h1 id="g:4">Booleans
</h1><div class="doc"><p>GHC already lifts booleans, defined as
</p><pre> data Bool = True | False
</pre><p>to types: Bool becomes kind and True and False (also denoted by
'True and 'False) become nullary type constructors.
</p><p>The above line is equivalent to
</p><pre> data HTrue
 data HFalse
</pre><pre> class HBool x
 instance HBool HTrue
 instance HBool HFalse
</pre></div><h2 id="g:5">Value-level proxies
</h2><div class="top"><p class="src"><a name="v:hTrue" class="def">hTrue</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></p></div><div class="top"><p class="src"><a name="v:hFalse" class="def">hFalse</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></p></div><h2 id="g:6">Conjunction
</h2><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HAnd" class="def">HAnd</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></p></div><div class="top"><p class="src"><a name="v:hAnd" class="def">hAnd</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t1 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t2 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#t:HAnd">HAnd</a> t1 t2)</p><div class="doc"><p><code>demote</code> to values
</p></div></div><h2 id="g:7">Disjunction
</h2><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HOr" class="def">HOr</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></p></div><div class="top"><p class="src"><a name="v:hOr" class="def">hOr</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t1 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t2 -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#t:HOr">HOr</a> t1 t2)</p><div class="doc"><p><code>demote</code> to values
</p></div></div><div class="doc"><p>Compare with the original code based on functional dependencies:
</p><pre> class (HBool t, HBool t', HBool t'') =&gt; HOr t t' t'' | t t' -&gt; t''
  where
   hOr :: t -&gt; t' -&gt; t''
</pre><pre> instance HOr HFalse HFalse HFalse
  where
   hOr _ _ = hFalse
</pre><pre> instance HOr HTrue HFalse HTrue
  where
   hOr _ _ = hTrue
</pre><pre> instance HOr HFalse HTrue HTrue
  where
   hOr _ _ = hTrue
</pre><pre> instance HOr HTrue HTrue HTrue
  where
   hOr _ _ = hTrue
</pre></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:HCond" class="def">HCond</a> t x y z | t x y -&gt; z <span class="keyword">where</span></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hCond" class="def">hCond</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> t -&gt; x -&gt; y -&gt; z</p></div><div class="subs instances"><p id="control.i:HCond" class="caption collapser" onclick="toggleSection('i:HCond')">Instances</p><div id="section.i:HCond" class="show"><table><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HCond">HCond</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a> x y y</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HCond">HCond</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a> x y x</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:8">Boolean equivalence
</h2><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HBoolEQ" class="def">HBoolEQ</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></p></div><h1 id="g:9">Naturals
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HNat" class="def">HNat</a>  </p><div class="doc"><p>The data type to be lifted to the type level
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HZero" class="def">HZero</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:HSucc" class="def">HSucc</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HNat" class="caption collapser" onclick="toggleSection('i:HNat')">Instances</p><div id="section.i:HNat" class="show"><table><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n n' b =&gt; <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n') b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HTypes2HNats">HTypes2HNats</a> [*] [*] ([] *) l ([] <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a>)</td><td class="doc"><p>And lift to the list of types
</p></td></tr><tr><td class="src">(<a href="Data-HList-HListPrelude.html#t:HType2HNat">HType2HNat</a> k [*] e l n, <a href="Data-HList-HListPrelude.html#t:HTypes2HNats">HTypes2HNats</a> [k] [*] es l ns) =&gt; <a href="Data-HList-HListPrelude.html#t:HTypes2HNats">HTypes2HNats</a> [k] [*] (: k e es) l (: <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n ns)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HArray.html#t:HLookupByHNat">HLookupByHNat</a> n l =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHLookupByHNat">FHLookupByHNat</a> l) (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> n =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> l, <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)) =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~ * ch (<a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Data-HList-FakePrelude.html#t:HBoolEQ">HBoolEQ</a> sel (<a href="Data-HList-HArray.html#t:KMember">KMember</a> n ns))), <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (ch, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)) =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> (: * e l), <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hZero" class="def">hZero</a> :: <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a></p></div><div class="top"><p class="src"><a name="v:hSucc" class="def">hSucc</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (n :: <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a>) -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)</p></div><div class="top"><p class="src"><a name="v:hPred" class="def">hPred</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> n</p></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:HNat2Integral" class="def">HNat2Integral</a> n  <span class="keyword">where</span></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hNat2Integral" class="def">hNat2Integral</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Integral">Integral</a> i =&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> n -&gt; i</p></div><div class="subs instances"><p id="control.i:HNat2Integral" class="caption collapser" onclick="toggleSection('i:HNat2Integral')">Instances</p><div id="section.i:HNat2Integral" class="show"><table><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> n =&gt; <a href="Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HNatEq" class="def">HNatEq</a> t1 t2 :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Equality on natural numbers
 (eventually to be subsumed by the universal polykinded HEq)
</p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HLt" class="def">HLt</a> x y :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Less than
</p></div></div><div class="top"><p class="src"><a name="v:hLt" class="def">hLt</a> ::  <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> x -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> y -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-FakePrelude.html#t:HLt">HLt</a> x y)</p></div><h1 id="g:10">Maybies
</h1><div class="doc"><p>We cannot use lifted Maybe since the latter are not populated
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:HNothing" class="def">HNothing</a>  </p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HNothing" class="def">HNothing</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HNothing" class="caption collapser" onclick="toggleSection('i:HNothing')">Instances</p><div id="section.i:HNothing" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Data-HList-FakePrelude.html#t:HNothing">HNothing</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p <a href="Data-HList-FakePrelude.html#t:HNothing">HNothing</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> l =&gt; <a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> (: * <a href="Data-HList-FakePrelude.html#t:HNothing">HNothing</a> l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:HJust" class="def">HJust</a> x </p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HJust" class="def">HJust</a> x</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HJust" class="caption collapser" onclick="toggleSection('i:HJust')">Instances</p><div id="section.i:HJust" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> p s, <a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p (<a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> p s)) =&gt; <a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> (e, s))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> x =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">~ * hJustA (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> t) a hJustA</td><td class="doc"><p><code>HJust ()</code> is a placeholder for a function that applies the <code><a href="Data-HList-FakePrelude.html#t:HJust">HJust</a></code> constructor
</p></td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> l =&gt; <a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> (: * (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> e) l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:ToHJust">ToHJust</a> l l' =&gt; <a href="Data-HList-HList.html#t:ToHJust">ToHJust</a> (: * e l) (: * (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> e) l')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:11">Polykinded Equality for types
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:HEq" class="def">HEq</a> x y b | x y -&gt; b</p><div class="doc"><p>We have to use Functional dependencies for now,
 for the sake of the generic equality.
</p></div><div class="subs instances"><p id="control.i:HEq" class="caption collapser" onclick="toggleSection('i:HEq')">Instances</p><div id="section.i:HEq" class="show"><table><tr><td class="src">~ <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a> b =&gt; <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k x y b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k x x <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n n' b =&gt; <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n') b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> [k] ([] k) ([] k) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> [k] ([] k) (: k e l) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> [k] (: k e l) ([] k) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k e1 e2 b1, <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> [k] l1 l2 b2, ~ <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> br (<a href="Data-HList-FakePrelude.html#t:HAnd">HAnd</a> b1 b2)) =&gt; <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> [k] (: k e1 l1) (: k e2 l2) br</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hEq" class="def">hEq</a> :: <a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> x y b =&gt; x -&gt; y -&gt; <a href="Data-HList-FakePrelude-Proxy.html#t:Proxy">Proxy</a> b</p></div><h1 id="g:12">Staged equality
</h1><h1 id="g:13">Type-safe cast -- no longer need. We use a a ~ b
</h1><h1 id="g:14">Error messages
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Fail" class="def">Fail</a> x </p><div class="doc"><p>A class without instances for explicit failure
</p></div></div><div class="top"><p class="src">module <a href="Data-HList-FakePrelude-Proxy.html">Data.HList.FakePrelude.Proxy</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>