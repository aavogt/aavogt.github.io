<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.CommonMain</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-CommonMain.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-HList-CommonMain.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.3.0.1: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Data.HList.CommonMain</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1"><a href="Data-HList-Keyword.html">Data.HList.Keyword</a>
</a></li><li><a href="#g:2">Labels
</a><ul><li><a href="#g:3">namespaced labels
</a></li></ul></li><li><a href="#g:4"><a href="Data-HList-Data.html">Data.HList.Data</a>
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The HList library
</p><p>This module re-exports everything needed to use HList.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="Data-HList-FakePrelude.html">Data.HList.FakePrelude</a></li><li class="src short">module <a href="Data-HList-HListPrelude.html">Data.HList.HListPrelude</a></li><li class="src short">module <a href="Data-HList-HArray.html">Data.HList.HArray</a></li><li class="src short">module <a href="Data-HList-HOccurs.html">Data.HList.HOccurs</a></li><li class="src short">module <a href="Data-HList-HTypeIndexed.html">Data.HList.HTypeIndexed</a></li><li class="src short">module <a href="Data-HList-Record.html">Data.HList.Record</a></li><li class="src short">module <a href="Data-HList-HList.html">Data.HList.HList</a></li><li class="src short">module <a href="Data-HList-TypeEqO.html">Data.HList.TypeEqO</a></li><li class="src short">module <a href="Data-HList-TIP.html">Data.HList.TIP</a></li><li class="src short">module <a href="Data-HList-TIC.html">Data.HList.TIC</a></li><li class="src short">module <a href="Data-HList-HZip.html">Data.HList.HZip</a></li><li class="src short">module <a href="Data-HList-Variant.html">Data.HList.Variant</a></li><li class="src short"><span class="keyword">class</span>  <a href="#t:Kw">Kw</a> fn arg_def r  <span class="keyword">where</span><ul class="subs"><li><a href="#v:kw">kw</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> (fn : arg_def) -&gt; r</li></ul></li><li class="src short"><a href="#v:recToKW">recToKW</a> :: <span class="keyword">forall</span> a b. (<a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> LVPairToKW a b, <a href="Data-HList-HList.html#t:SameLength">SameLength</a> a b, <a href="Data-HList-HList.html#t:SameLength">SameLength</a> b a, <a href="Data-HList-HList.html#t:HConcat">HConcat</a> b) =&gt; <a href="Data-HList-Record.html#t:Record">Record</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HConcatR">HConcatR</a> b)</li><li class="src short"><span class="keyword">class</span>  <a href="#t:IsKeyFN">IsKeyFN</a> t flag | t -&gt; flag</li><li class="src short"><span class="keyword">data</span>  <a href="#t:K">K</a> s c</li><li class="src short"><span class="keyword">data</span>  <a href="#t:ErrReqdArgNotFound">ErrReqdArgNotFound</a> x</li><li class="src short"><span class="keyword">data</span>  <a href="#t:ErrUnexpectedKW">ErrUnexpectedKW</a> x</li><li class="src short">module <a href="Data-HList-Labelable.html">Data.HList.Labelable</a></li><li class="src short">module <a href="Data-HList-Label3.html">Data.HList.Label3</a></li><li class="src short">module <a href="Data-HList-MakeLabels.html">Data.HList.MakeLabels</a></li><li class="src short">module <a href="Data-HList-RecordPuns.html">Data.HList.RecordPuns</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src">module <a href="Data-HList-FakePrelude.html">Data.HList.FakePrelude</a></p></div><div class="top"><p class="src">module <a href="Data-HList-HListPrelude.html">Data.HList.HListPrelude</a></p></div><div class="top"><p class="src">module <a href="Data-HList-HArray.html">Data.HList.HArray</a></p></div><div class="top"><p class="src">module <a href="Data-HList-HOccurs.html">Data.HList.HOccurs</a></p></div><div class="top"><p class="src">module <a href="Data-HList-HTypeIndexed.html">Data.HList.HTypeIndexed</a></p></div><div class="top"><p class="src">module <a href="Data-HList-Record.html">Data.HList.Record</a></p></div><div class="top"><p class="src">module <a href="Data-HList-HList.html">Data.HList.HList</a></p></div><div class="top"><p class="src">module <a href="Data-HList-TypeEqO.html">Data.HList.TypeEqO</a></p></div><div class="top"><p class="src">module <a href="Data-HList-TIP.html">Data.HList.TIP</a></p></div><div class="top"><p class="src">module <a href="Data-HList-TIC.html">Data.HList.TIC</a></p></div><div class="top"><p class="src">module <a href="Data-HList-HZip.html">Data.HList.HZip</a></p></div><div class="top"><p class="src">module <a href="Data-HList-Variant.html">Data.HList.Variant</a></p></div><h1 id="g:1"><a href="Data-HList-Keyword.html">Data.HList.Keyword</a>
</h1><div class="doc"><p>the &quot;public&quot; parts. More examples are in the module documentation.
</p></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Kw" class="def">Kw</a> fn arg_def r  <span class="keyword">where</span><a href="src/Data-HList-Keyword.html#Kw" class="link">Source</a></p><div class="doc"><p><code>kw</code> takes a <code><a href="Data-HList-HList.html#t:HList">HList</a></code> whose first element is a function, and the rest
of the elements are default values.
A useful trick is to have a final argument <code>()</code> which is not
eaten up by a label (A only takes 1 argument). That way when you supply
the () it knows there are no more arguments (?).
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data A = A
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance IsKeyFN (A -&gt; a -&gt; b) True
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f A a () = a + 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f' = f .*. A .*. 1 .*. HNil
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' A 0 ()
</code></strong>1
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' ()
</code></strong>2
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kw" class="def">kw</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> (fn : arg_def) -&gt; r<a href="src/Data-HList-Keyword.html#kw" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Kw" class="caption collapser" onclick="toggleSection('i:Kw')">Instances</p><div id="section.i:Kw" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:KW-39-">KW'</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> rflag fn akws arg_def r, ~ * akws (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> [*] kws ([] *)), <a href="Data-HList-Keyword.html#t:ReflectFK-39-">ReflectFK'</a> * [*] flag fn kws, <a href="Data-HList-CommonMain.html#t:IsKeyFN">IsKeyFN</a> * r rflag, <a href="Data-HList-CommonMain.html#t:IsKeyFN">IsKeyFN</a> * fn flag) =&gt; <a href="Data-HList-CommonMain.html#t:Kw">Kw</a> fn arg_def r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:recToKW" class="def">recToKW</a> :: <span class="keyword">forall</span> a b. (<a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> LVPairToKW a b, <a href="Data-HList-HList.html#t:SameLength">SameLength</a> a b, <a href="Data-HList-HList.html#t:SameLength">SameLength</a> b a, <a href="Data-HList-HList.html#t:HConcat">HConcat</a> b) =&gt; <a href="Data-HList-Record.html#t:Record">Record</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HConcatR">HConcatR</a> b)<a href="src/Data-HList-Keyword.html#recToKW" class="link">Source</a></p><div class="doc"><p>convert a <code><a href="Data-HList-Record.html#t:Record">Record</a></code> into a list that can supply
default arguments for <code><a href="Data-HList-CommonMain.html#v:kw">kw</a></code>
</p><p>A bit of setup:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XQuasiQuotes
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f (_ :: Label &quot;a&quot;) a (_ :: Label &quot;b&quot;) b () = a `div` b
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = 2; b = 1; f' = f .*. recToKW [pun| a b |]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' ()
</code></strong>2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' (Label :: Label &quot;a&quot;) 10 ()
</code></strong>10
</pre></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:IsKeyFN" class="def">IsKeyFN</a> t flag | t -&gt; flag<a href="src/Data-HList-Keyword.html#IsKeyFN" class="link">Source</a></p><div class="doc"><p>All our keywords must be registered
</p></div><div class="subs instances"><p id="control.i:IsKeyFN" class="caption collapser" onclick="toggleSection('i:IsKeyFN')">Instances</p><div id="section.i:IsKeyFN" class="show"><table><tr><td class="src">~ <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a> flag =&gt; <a href="Data-HList-CommonMain.html#t:IsKeyFN">IsKeyFN</a> k t flag</td><td class="doc"><p>overlapping/fallback case
</p></td></tr><tr><td class="src"><a href="Data-HList-CommonMain.html#t:IsKeyFN">IsKeyFN</a> * (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> s -&gt; a -&gt; b) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc"><p>labels that impose no restriction on the type of the (single) argument
 which follows
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (_ :: Label &quot;a&quot;) (a :: Int) () = a+1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (Label :: Label &quot;a&quot;) 5 ()
</code></strong>6
</pre></td></tr><tr><td class="src">~ * r (c -&gt; b) =&gt; <a href="Data-HList-CommonMain.html#t:IsKeyFN">IsKeyFN</a> * (<a href="Data-HList-CommonMain.html#t:K">K</a> k s c -&gt; r) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc"><p>The purpose of this instance is to be able to use the same Symbol
 (type-level string) at different types. If they are supposed to be the same,
 then use <code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code> instead of <code><a href="Data-HList-CommonMain.html#t:K">K</a></code>
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let kA = K :: forall t. K &quot;a&quot; t
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (K :: K &quot;a&quot; Int) a1 (K :: K &quot;a&quot; Integer) a2 () = a1-fromIntegral a2
</code></strong></pre><p>therefore the following options works:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) kA (5 :: Int) kA (3 :: Integer) ()
</code></strong>2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (K :: K &quot;a&quot; Integer) 3 (K :: K &quot;a&quot; Int) 5 ()
</code></strong>2
</pre><p>But you cannot leave off all <code>Int</code> or <code>Integer</code> annotations.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:K" class="def">K</a> s c <a href="src/Data-HList-Keyword.html#K" class="link">Source</a></p><div class="subs instances"><p id="control.i:K" class="caption collapser" onclick="toggleSection('i:K')">Instances</p><div id="section.i:K" class="show"><table><tr><td class="src">~ * r (c -&gt; b) =&gt; <a href="Data-HList-CommonMain.html#t:IsKeyFN">IsKeyFN</a> * (<a href="Data-HList-CommonMain.html#t:K">K</a> k s c -&gt; r) <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc"><p>The purpose of this instance is to be able to use the same Symbol
 (type-level string) at different types. If they are supposed to be the same,
 then use <code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code> instead of <code><a href="Data-HList-CommonMain.html#t:K">K</a></code>
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let kA = K :: forall t. K &quot;a&quot; t
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (K :: K &quot;a&quot; Int) a1 (K :: K &quot;a&quot; Integer) a2 () = a1-fromIntegral a2
</code></strong></pre><p>therefore the following options works:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) kA (5 :: Int) kA (3 :: Integer) ()
</code></strong>2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (K :: K &quot;a&quot; Integer) 3 (K :: K &quot;a&quot; Int) 5 ()
</code></strong>2
</pre><p>But you cannot leave off all <code>Int</code> or <code>Integer</code> annotations.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ErrReqdArgNotFound" class="def">ErrReqdArgNotFound</a> x <a href="src/Data-HList-Keyword.html#ErrReqdArgNotFound" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ErrUnexpectedKW" class="def">ErrUnexpectedKW</a> x <a href="src/Data-HList-Keyword.html#ErrUnexpectedKW" class="link">Source</a></p></div><h1 id="g:2">Labels
</h1><div class="doc"><p>there are really only two options for now, but there are
   a couple different styles for the first option here:
</p><p>GHC supports type-level strings (<code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a></code>), and these can be
   labels. You can refer to these strings using an unwieldy syntax. For
   example if you want to store a value <code>5</code> in a record <code>rec</code> with a field
   called <code>&quot;x&quot;</code>, and then get it out again:
</p><p>let rec = (<code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code> :: Label &quot;x&quot;) <code><a href="Data-HList-Record.html#v:.-61-.">.=.</a></code> 5 <code><a href="Data-HList-HListPrelude.html#v:.-42-.">.*.</a></code> <code><a href="Data-HList-Record.html#v:emptyRecord">emptyRecord</a></code>
</p><p>rec <code><a href="Data-HList-Record.html#v:.-33-.">.!.</a></code> (Label :: Label &quot;x&quot;)
</p><p>To avoid that pain, you can have a definition <code>x = Label :: Label <a href="x.html">x</a></code>.
   and just use <code>x</code> instead of repeating <code>Label :: Label &quot;x&quot;</code> so that
   a lookup becomes:
</p><pre> rec .!. x
</pre><p>See <code><a href="Data-HList-MakeLabels.html#v:makeLabels6">makeLabels6</a></code> for automating the <code>x = Label :: Label &quot;x&quot;</code>.
</p></div><div class="doc"><p><a name="label6demo"></a>
</p><p>Instances from <a href="Data-HList-Label6.html">Data.HList.Label6</a>
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDataKinds
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(Label :: Label &quot;x&quot;) .=. (5::Int) .*. emptyRecord
</code></strong>Record{x=5}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = Label :: Label &quot;x&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r = x .=. (5::Int) .*. emptyRecord
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>r .!. x
</code></strong>5
</pre></div><div class="top"><p class="src">module <a href="Data-HList-Labelable.html">Data.HList.Labelable</a></p></div><div class="doc"><p><a name="labelabledemo"></a>
</p><p>Rather than having the <code>x = Label :: Label &quot;x&quot;</code>, the labels
generated by <code><a href="Data-HList-Labelable.html#v:makeLabelable">makeLabelable</a></code> also double lenses for <a href="Control-Lens.html">Control.Lens</a>.
Here is an example of how much better that is:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XNoMonomorphismRestriction -XDataKinds -XPolyKinds
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Control.Lens
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = hLens' (Label :: Label &quot;x&quot;)
</code></strong></pre><p>The Label6 method:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r = (Label :: Label &quot;x&quot;) .=. &quot;5&quot; .*. emptyRecord
</code></strong></pre><p>The Labelable way:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r2 = x .==. &quot;5&quot; .*. emptyRecord
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>r ^. x
</code></strong>&quot;5&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>r2 ^. x
</code></strong>&quot;5&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>r &amp; x .~ ()
</code></strong>Record{x=()}
</pre></div><h2 id="g:3">namespaced labels
</h2><div class="top"><p class="src">module <a href="Data-HList-Label3.html">Data.HList.Label3</a></p></div><div class="doc"><p>template haskell for automating different types of labels
</p></div><div class="top"><p class="src">module <a href="Data-HList-MakeLabels.html">Data.HList.MakeLabels</a></p></div><div class="doc"><p>quasiquoter <code><a href="Data-HList-RecordPuns.html#v:pun">pun</a></code> helps to avoid needing a proxy value with
 type <code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code> in the first place: when you take values out of or into
 records with pattern matching, the variable name determines the label
 name.
</p></div><div class="top"><p class="src">module <a href="Data-HList-RecordPuns.html">Data.HList.RecordPuns</a></p></div><h1 id="g:4"><a href="Data-HList-Data.html">Data.HList.Data</a>
</h1><div class="doc"><p>This modules provide useful instances. A useful application can be
 found in <code>examples/cmdargs.hs</code>
</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>