<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.Labelable</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-Labelable.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.3.0.1: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Data.HList.Labelable</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">comparison with <code><a href="Data-HList-Record.html#v:hLens">hLens</a></code>
</a></li><li><a href="#g:2">likely unneeded (re)exports
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A simple problem is being solved here, but unfortunately it
is a bit involved. The idea is to use the same haskell identifier 
for a lens and for other purposes. In other words, get the same
behavior as:
</p><pre> x = hLens (Label :: Label &quot;x&quot;)
 r ^. x
</pre><p>While still being able to extract the symbol &quot;x&quot; from x, so that things
like <code>x .=. 123</code> could be acceptable. In this case we don't overload <code><a href="Data-HList-Record.html#v:.-61-.">.=.</a></code>,
so instead you have to write <code>x .==. 123</code>.
</p><p>Elaboration of some ideas from edwardk.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:makeLabelable">makeLabelable</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><span class="keyword">class</span>  <a href="#t:Labelable">Labelable</a> l p f s t a b | l s -&gt; a, l t -&gt; b, l s b -&gt; t, l t a -&gt; s <span class="keyword">where</span><ul class="subs"><li><a href="#v:hLens-39-">hLens'</a> :: <a href="Data-HList-FakePrelude.html#t:Label">Label</a> l -&gt; p (a -&gt; f b) (<a href="Data-HList-Record.html#t:Record">Record</a> s -&gt; f (<a href="Data-HList-Record.html#t:Record">Record</a> t))</li></ul></li><li class="src short"><a href="#v:.-61--61-.">(.==.)</a> :: <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> * <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> t l =&gt; t -&gt; v -&gt; <a href="Data-HList-Record.html#t:LVPair">LVPair</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> l v</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Labeled">Labeled</a> l a b = <a href="#v:Labeled">Labeled</a></li><li class="src short"><a href="#v:toLabel">toLabel</a> :: <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> t t' =&gt; t -&gt; <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (t' :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a>)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Identity">Identity</a> a</li><li class="src short"><span class="keyword">class</span>  <a href="#t:ToSym">ToSym</a> a b </li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:makeLabelable" class="def">makeLabelable</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</p><div class="doc"><p><code>makeLabelable &quot;x y z&quot;</code> will generate haskell identifiers that work with <code><a href="Data-HList-Labelable.html#v:.-61--61-.">.==.</a></code> and
are also lenses.
</p><pre> x = hLens' (Label :: Label &quot;x&quot;)
 y = hLens' (Label :: Label &quot;y&quot;)
 z = hLens' (Label :: Label &quot;z&quot;)
</pre></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Labelable" class="def">Labelable</a> l p f s t a b | l s -&gt; a, l t -&gt; b, l s b -&gt; t, l t a -&gt; s <span class="keyword">where</span></p><div class="doc"><p><code>f s t a b</code> type parameters are the same as those that make
<a href="Control-Lens.html">Control.Lens</a> work.
</p><dl><dt><code>n</code></dt><dd> is the index in the HList at which the value will be found
</dd><dt><code>l</code></dt><dd> is the label for the field (tends to be <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a></code>)
</dd><dt><code>p</code></dt><dd> is <code>-&gt;</code> when the result is used as a lens, or <code><a href="Data-HList-Labelable.html#t:Labeled">Labeled</a></code> when used
      as an argument to <code><a href="Data-HList-Labelable.html#v:.-61--61-.">.==.</a></code>
</dd></dl></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hLens-39-" class="def">hLens'</a> :: <a href="Data-HList-FakePrelude.html#t:Label">Label</a> l -&gt; p (a -&gt; f b) (<a href="Data-HList-Record.html#t:Record">Record</a> s -&gt; f (<a href="Data-HList-Record.html#t:Record">Record</a> t))</p></div><div class="subs instances"><p id="control.i:Labelable" class="caption collapser" onclick="toggleSection('i:Labelable')">Instances</p><div id="section.i:Labelable" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> f, <a href="Data-HList-Record.html#t:HasField">HasField</a> k x (<a href="Data-HList-Record.html#t:Record">Record</a> s) a, <a href="Data-HList-Record.html#t:HasField">HasField</a> k x (<a href="Data-HList-Record.html#t:Record">Record</a> t) b, <a href="Data-HList-HList.html#t:HFind">HFind</a> k x (<a href="Data-HList-Record.html#t:RecordLabels">RecordLabels</a> k t) n, <a href="Data-HList-HList.html#t:HFind">HFind</a> k x (<a href="Data-HList-Record.html#t:RecordLabels">RecordLabels</a> k s) n, <a href="Data-HList-HArray.html#t:HUpdateAtHNat">HUpdateAtHNat</a> n (<a href="Data-HList-Record.html#t:LVPair">LVPair</a> k x b) s, ~ [*] t (<a href="Data-HList-HArray.html#t:HUpdateAtHNatR">HUpdateAtHNatR</a> n (<a href="Data-HList-Record.html#t:LVPair">LVPair</a> k x b) s)) =&gt; <a href="Data-HList-Labelable.html#t:Labelable">Labelable</a> k x (-&gt;) f s t a b</td><td class="doc"><p>make a lens
</p></td></tr><tr><td class="src">(~ (* -&gt; *) f <a href="Data-HList-Labelable.html#t:Identity">Identity</a>, ~ [*] s ([] *), ~ [*] t ([] *), ~ * a (), ~ * b (), ~ k x' x) =&gt; <a href="Data-HList-Labelable.html#t:Labelable">Labelable</a> k x' (<a href="Data-HList-Labelable.html#t:Labeled">Labeled</a> k x) f s t a b</td><td class="doc"><p>make a data type that allows recovering the field name
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:.-61--61-." class="def">(.==.)</a> :: <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> * <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> t l =&gt; t -&gt; v -&gt; <a href="Data-HList-Record.html#t:LVPair">LVPair</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a> l v</p><div class="doc"><p>modification of <code><a href="Data-HList-Record.html#v:.-61-.">.=.</a></code> which works with the labels from this module,
 and those from <a href="Data-HList-Label6.html">Data.HList.Label6</a>. Note that this is not strictly a
 generalization of <code><a href="Data-HList-Record.html#v:.-61-.">.=.</a></code>, since it does not work with labels like
 <a href="Data-HList-Label3.html">Data.HList.Label3</a> which have the wrong kind.
</p></div></div><h1 id="g:1">comparison with <code><a href="Data-HList-Record.html#v:hLens">hLens</a></code>
</h1><div class="doc"><p>Note that passing around variables defined with <code><a href="Data-HList-Labelable.html#v:hLens-39-">hLens'</a></code> doesn't get
you exactly the same thing as calling <code><a href="Data-HList-Record.html#v:hLens">hLens</a></code> at the call-site:
</p><p>The following code needs to apply the <code>x</code> for different <code>Functor
f =&gt;</code>, so you would have to write a type signature (rank-2) to allow this
definition:
</p><pre> -- with the x defined using hLens'
 let f x r = let
          a = r ^. x
          b = r &amp; x .~ &quot;6&quot;
        in (a,b)
</pre><p>This alternative won't need a type signature
</p><pre> -- with the x defined as x = Label :: Label &quot;x&quot;
 let f x r = let
          a = r ^. hLens x
          b = r &amp; hLens x .~ &quot;6&quot;
        in (a,b)
</pre><p>It may work to use <code><a href="Data-HList-Labelable.html#v:hLens-39-">hLens'</a></code> instead of <code><a href="Data-HList-Record.html#v:hLens">hLens</a></code> in the second code,
but that is a bit beside the point being made here.
</p></div><h1 id="g:2">likely unneeded (re)exports
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Labeled" class="def">Labeled</a> l a b </p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Labeled" class="def">Labeled</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Labeled" class="caption collapser" onclick="toggleSection('i:Labeled')">Instances</p><div id="section.i:Labeled" class="show"><table><tr><td class="src">(~ (* -&gt; *) f <a href="Data-HList-Labelable.html#t:Identity">Identity</a>, ~ [*] s ([] *), ~ [*] t ([] *), ~ * a (), ~ * b (), ~ k x' x) =&gt; <a href="Data-HList-Labelable.html#t:Labelable">Labelable</a> k x' (<a href="Data-HList-Labelable.html#t:Labeled">Labeled</a> k x) f s t a b</td><td class="doc"><p>make a data type that allows recovering the field name
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-Labelable.html#t:Labeled">Labeled</a> k l a b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:toLabel" class="def">toLabel</a> :: <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> t t' =&gt; t -&gt; <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (t' :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-TypeLits.html#t:Symbol">Symbol</a>)</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Identity" class="def">Identity</a> a </p><div class="doc"><p>Identity functor and monad.
</p></div><div class="subs instances"><p id="control.i:Identity" class="caption collapser" onclick="toggleSection('i:Identity')">Instances</p><div id="section.i:Identity" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> <a href="Data-HList-Labelable.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Data-HList-Labelable.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> <a href="Data-HList-Labelable.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> <a href="Data-HList-Labelable.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Foldable.html#t:Foldable">Foldable</a> <a href="Data-HList-Labelable.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Traversable.html#t:Traversable">Traversable</a> <a href="Data-HList-Labelable.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:ToSym" class="def">ToSym</a> a b </p><div class="doc"><p>extracts the type that is actually the label in <code>a</code> and puts it in <code>b</code>
</p></div><div class="subs instances"><p id="control.i:ToSym" class="caption collapser" onclick="toggleSection('i:ToSym')">Instances</p><div id="section.i:ToSym" class="show"><table><tr><td class="src">~ k x x' =&gt; <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> * k (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> k x) x'</td><td class="doc"><p>for <a href="Data-HList-Label6.html">Data.HList.Label6</a> labels
</p></td></tr><tr><td class="src">(~ k x x', ~ (* -&gt; * -&gt; *) p (<a href="Data-HList-Labelable.html#t:Labeled">Labeled</a> k x')) =&gt; <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> * k (p a b) x'</td><td class="doc"><p>for labels in this module
</p></td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>