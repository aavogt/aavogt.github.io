<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.HList</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-HList.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-HList-HList.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.3.4.1: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.HList.HList</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Heterogeneous type sequences</a><ul><li><a href="#g:2">Alternative representation</a></li></ul></li><li><a href="#g:3">Basic list functions</a><ul><li><a href="#g:4">Append</a></li><li><a href="#g:5">Alternative append</a></li><li><a href="#g:6">Historical append</a></li></ul></li><li><a href="#g:7">Reversing HLists</a></li><li><a href="#g:8">A nicer notation for lists</a><ul><li><a href="#g:9">examples</a><ul><li><a href="#g:10">historical</a></li></ul></li></ul></li><li><a href="#g:11">folds</a><ul><li><a href="#g:12">foldr</a></li><li><a href="#g:13">foldl</a></li></ul></li><li><a href="#g:14">unfold</a></li><li><a href="#g:15">replicate</a></li><li><a href="#g:16">concat</a></li><li><a href="#g:17">traversing HLists</a><ul><li><a href="#g:18">producing HList</a><ul><li><a href="#g:19">map</a><ul><li><a href="#g:20">alternative implementation</a></li></ul></li><li><a href="#g:21"><code>appEndo . mconcat . map Endo</code></a></li><li><a href="#g:22">sequence</a><ul><li><a href="#g:23">alternative implementation</a></li></ul></li></ul></li><li><a href="#g:24">producing homogenous lists</a><ul><li><a href="#g:25">map (no sequencing)</a></li><li><a href="#g:26">mapM</a></li></ul></li></ul></li><li><a href="#g:27">Type-level equality for lists (<code>HEq</code>)</a></li><li><a href="#g:28">Ensure a list to contain HNats only</a></li><li><a href="#g:29">Membership tests</a><ul><li><a href="#g:30">Another type-level membership test</a></li></ul></li><li><a href="#g:31">Staged equality for lists</a></li><li><a href="#g:32">Find an element in a set based on HEq</a><ul><li><a href="#g:33">Membership test based on type equality</a></li></ul></li><li><a href="#g:34">Intersection based on HTMember</a></li><li><a href="#g:35">Turn a heterogeneous list into a homogeneous one</a></li><li><a href="#g:36">With <code>HMaybe</code></a><ul><li><a href="#g:37">Turn list in a list of justs</a></li><li><a href="#g:38">Extract justs from list of maybes</a><ul><li><a href="#g:39">alternative implementation</a></li></ul></li></ul></li><li><a href="#g:40">Annotated lists</a></li><li><a href="#g:41">Splitting by HTrue and HFalse</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The HList library</p><p>(C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke</p><p>Basic declarations for typeful heterogeneous lists.</p><p>Excuse the unstructured haddocks: while there are many declarations here
   some are alternative implementations should be grouped, and the definitions
   here are analgous to many list functions in the <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html">Prelude</a>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:HList">HList</a> l <span class="keyword">where</span><ul class="subs"><li><a href="#v:HNil">HNil</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> []</li><li><a href="#v:HCons">HCons</a> ::  e -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (e : l)</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:HNil-39-">HNil'</a> = <a href="#v:HNil-39-">HNil'</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:HCons-39-">HCons'</a> a b = <a href="#v:HCons-39-">HCons'</a> a b</li><li class="src short"><span class="keyword">class</span> (<a href="Data-HList-HList.html#t:UnPrime">UnPrime</a> (<a href="Data-HList-HList.html#t:Prime">Prime</a> a) ~ a) =&gt; <a href="#t:ConvHList">ConvHList</a> a <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:Prime">Prime</a> a :: *</li><li><span class="keyword">type</span> <a href="#t:UnPrime">UnPrime</a> b :: [*]</li><li><a href="#v:prime">prime</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> a -&gt; <a href="Data-HList-HList.html#t:Prime">Prime</a> a</li><li><a href="#v:unPrime">unPrime</a> :: <a href="Data-HList-HList.html#t:Prime">Prime</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> a</li></ul></li><li class="src short"><a href="#v:hHead">hHead</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> (e : l) -&gt; e</li><li class="src short"><a href="#v:hTail">hTail</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> (e : l) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l</li><li class="src short"><span class="keyword">type family</span> <a href="#t:HLength">HLength</a> x :: <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a></li><li class="src short"><a href="#v:hLength">hLength</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-HList.html#t:HLength">HLength</a> l)</li><li class="src short"><span class="keyword">type family</span> <a href="#t:HAppendList">HAppendList</a> l1 l2 :: [k]</li><li class="src short"><a href="#v:hAppendList">hAppendList</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> l1 l2)</li><li class="src short"><a href="#v:append-39-">append'</a> ::  [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:hAppend-39-">hAppend'</a> :: <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> <a href="Data-HList-HList.html#t:FHCons">FHCons</a> v l r =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; v -&gt; r</li><li class="src short"><span class="keyword">data</span> <a href="#t:FHCons">FHCons</a> = <a href="#v:FHCons">FHCons</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HRevApp">HRevApp</a> l1 l2 :: [k]</li><li class="src short"><a href="#v:hRevApp">hRevApp</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> l1 l2)</li><li class="src short"><a href="#v:hReverse">hReverse</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> * l1 ([] *))</li><li class="src short"><a href="#v:hEnd">hEnd</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l</li><li class="src short"><a href="#v:hBuild">hBuild</a> :: <a href="Data-HList-HList.html#t:HBuild-39-">HBuild'</a> [] r =&gt; r</li><li class="src short"><span class="keyword">class</span> <a href="#t:HBuild-39-">HBuild'</a> l r <span class="keyword">where</span><ul class="subs"><li><a href="#v:hBuild-39-">hBuild'</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HFoldr">HFoldr</a> f v l r <span class="keyword">where</span><ul class="subs"><li><a href="#v:hFoldr">hFoldr</a> :: f -&gt; v -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HScanr">HScanr</a> f z ls rs <span class="keyword">where</span><ul class="subs"><li><a href="#v:hScanr">hScanr</a> :: f -&gt; z -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> ls -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> rs</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HFoldr1">HFoldr1</a> f l r <span class="keyword">where</span><ul class="subs"><li><a href="#v:hFoldr1">hFoldr1</a> :: f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HFoldl">HFoldl</a> f z xs r <span class="keyword">where</span><ul class="subs"><li><a href="#v:hFoldl">hFoldl</a> :: f -&gt; z -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> xs -&gt; r</li></ul></li><li class="src short"><a href="#v:hUnfold">hUnfold</a> :: (<a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> p s, <a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p (<a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> p s)) =&gt; p -&gt; s -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HUnfold">HUnfold</a> p s)</li><li class="src short"><span class="keyword">type</span> <a href="#t:HUnfold">HUnfold</a> p s = <a href="Data-HList-HList.html#t:HUnfoldR">HUnfoldR</a> p (<a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> p s)</li><li class="src short"><span class="keyword">class</span> <a href="#t:HUnfold-39-">HUnfold'</a> p res <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:HUnfoldR">HUnfoldR</a> p res :: [*]</li><li><a href="#v:hUnfold-39-">hUnfold'</a> :: p -&gt; res -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HUnfoldR">HUnfoldR</a> p res)</li></ul></li><li class="src short"><span class="keyword">class</span> (<a href="Data-HList-HList.html#t:HLength">HLength</a> (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n e) ~ n) =&gt; <a href="#t:HReplicate">HReplicate</a> n e <span class="keyword">where</span><ul class="subs"><li><a href="#v:hReplicate">hReplicate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> n -&gt; e -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n e)</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HReplicateR">HReplicateR</a> n e :: [k]</li><li class="src short"><span class="keyword">class</span> <a href="#t:HConcat">HConcat</a> a <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:HConcatR">HConcatR</a> a :: [*]</li><li><a href="#v:hConcat">hConcat</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HConcatR">HConcatR</a> a)</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:UnHList">UnHList</a> a :: [*]</li><li class="src short"><a href="#v:hMap">hMap</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f as' bs') =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs'</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:HMap">HMap</a> f = <a href="#v:HMap">HMap</a> f</li><li class="src short"><span class="keyword">type</span> <a href="#t:HMapCxt">HMapCxt</a> f as bs as' bs' = (<a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f as' bs', as ~ <a href="Data-HList-HList.html#t:HList">HList</a> as', bs ~ <a href="Data-HList-HList.html#t:HList">HList</a> bs', <a href="Data-HList-HList.html#t:SameLength">SameLength</a> as' bs')</li><li class="src short"><span class="keyword">class</span> <a href="#t:SameLength-39-">SameLength'</a> es1 es2</li><li class="src short"><span class="keyword">class</span> (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> x y, <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> y x) =&gt; <a href="#t:SameLength">SameLength</a> x y</li><li class="src short"><span class="keyword">class</span> <a href="#t:HMapAux">HMapAux</a> f l r <span class="keyword">where</span><ul class="subs"><li><a href="#v:hMapAux">hMapAux</a> :: <a href="Data-HList-HList.html#t:SameLength">SameLength</a> l r =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> r</li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:MapCar">MapCar</a> f = <a href="#v:MapCar">MapCar</a> f</li><li class="src short"><a href="#v:hMapMapCar">hMapMapCar</a> :: <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> (<a href="Data-HList-HList.html#t:MapCar">MapCar</a> f) (<a href="Data-HList-HList.html#t:HList">HList</a> []) l l' =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; l'</li><li class="src short"><a href="#v:hComposeList">hComposeList</a> :: <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> <a href="Data-HList-FakePrelude.html#t:Comp">Comp</a> (a -&gt; a) l (t -&gt; a) =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; t -&gt; a</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m, <a href="Data-HList-HList.html#t:SameLength">SameLength</a> a b) =&gt; <a href="#t:HSequence">HSequence</a> m a b | a -&gt; b, m b -&gt; a <span class="keyword">where</span><ul class="subs"><li><a href="#v:hSequence">hSequence</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> a -&gt; m (<a href="Data-HList-HList.html#t:HList">HList</a> b)</li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:LiftA2">LiftA2</a> f = <a href="#v:LiftA2">LiftA2</a> f</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Mapcar">Mapcar</a> f = <a href="#v:Mapcar">Mapcar</a> f</li><li class="src short"><span class="keyword">type</span> <a href="#t:HMapOut">HMapOut</a> f l e = <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> (<a href="Data-HList-HList.html#t:Mapcar">Mapcar</a> f) [e] l [e]</li><li class="src short"><a href="#v:hMapOut">hMapOut</a> :: <span class="keyword">forall</span> f e l. <a href="Data-HList-HList.html#t:HMapOut">HMapOut</a> f l e =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; [e]</li><li class="src short"><a href="#v:hMapM">hMapM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-HList-HList.html#t:HMapOut">HMapOut</a> f l (m e)) =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; [m e]</li><li class="src short"><a href="#v:hMapM_">hMapM_</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-HList-HList.html#t:HMapOut">HMapOut</a> f l (m ())) =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; m ()</li><li class="src short"><span class="keyword">type family</span> <a href="#t:HNats">HNats</a> l :: [<a href="Data-HList-FakePrelude.html#t:HNat">HNat</a>]</li><li class="src short"><a href="#v:hNats">hNats</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-HList.html#t:HNats">HNats</a> l)</li><li class="src short"><span class="keyword">class</span> <a href="#t:HMember">HMember</a> e1 l b | e1 l -&gt; b</li><li class="src short"><span class="keyword">class</span> <a href="#t:HMember-39-">HMember'</a> b0 e1 l b | b0 e1 l -&gt; b</li><li class="src short"><span class="keyword">type family</span> <a href="#t:HMemberP">HMemberP</a> pred e1 l :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HMemberP-39-">HMemberP'</a> pred e1 l pb :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:hMember">hMember</a> :: <a href="Data-HList-HList.html#t:HMember">HMember</a> e l b =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> b</li><li class="src short"><span class="keyword">class</span> <a href="#t:HMemberM">HMemberM</a> e1 l r | e1 l -&gt; r</li><li class="src short"><span class="keyword">class</span> <a href="#t:HMemberM1">HMemberM1</a> b e1 l r | b e1 l -&gt; r</li><li class="src short"><span class="keyword">class</span> <a href="#t:HMemberM2">HMemberM2</a> b e1 l r | b e1 l -&gt; r</li><li class="src short"><span class="keyword">class</span> <a href="#t:HFind">HFind</a> e l n | e l -&gt; n</li><li class="src short"><span class="keyword">class</span> <a href="#t:HFind-39-">HFind'</a> b e l n | b e l -&gt; n</li><li class="src short"><span class="keyword">class</span> <a href="#t:HTMember">HTMember</a> e l b | e l -&gt; b</li><li class="src short"><a href="#v:hTMember">hTMember</a> :: <a href="Data-HList-HList.html#t:HTMember">HTMember</a> e l b =&gt; e -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> b</li><li class="src short"><span class="keyword">class</span> <a href="#t:HTIntersect">HTIntersect</a> l1 l2 l3 | l1 l2 -&gt; l3 <span class="keyword">where</span><ul class="subs"><li><a href="#v:hTIntersect">hTIntersect</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l3</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HTIntersectBool">HTIntersectBool</a> b h t l1 l2 | b h t l1 -&gt; l2 <span class="keyword">where</span><ul class="subs"><li><a href="#v:hTIntersectBool">hTIntersectBool</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> b -&gt; h -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> t -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HList2List">HList2List</a> l e <span class="keyword">where</span><ul class="subs"><li><a href="#v:hList2List">hList2List</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; [e]</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:ToHJust">ToHJust</a> l l' | l -&gt; l', l' -&gt; l <span class="keyword">where</span><ul class="subs"><li><a href="#v:toHJust">toHJust</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l'</li></ul></li><li class="src short"><a href="#v:toHJust2">toHJust2</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> ()) as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs'</li><li class="src short"><span class="keyword">class</span> <a href="#t:FromHJust">FromHJust</a> l <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:FromHJustR">FromHJustR</a> l :: [*]</li><li><a href="#v:fromHJust">fromHJust</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:FromHJustR">FromHJustR</a> l)</li></ul></li><li class="src short"><a href="#v:fromHJust2">fromHJust2</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> <a href="Data-HList-HList.html#t:HFromJust">HFromJust</a> as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs'</li><li class="src short"><span class="keyword">data</span> <a href="#t:HFromJust">HFromJust</a> = <a href="#v:HFromJust">HFromJust</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:HAddTag">HAddTag</a> t = <a href="#v:HAddTag">HAddTag</a> t</li><li class="src short"><span class="keyword">data</span> <a href="#t:HRmTag">HRmTag</a> = <a href="#v:HRmTag">HRmTag</a></li><li class="src short"><a href="#v:hAddTag">hAddTag</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="Data-HList-HList.html#t:HAddTag">HAddTag</a> t) as' bs') =&gt; t -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs'</li><li class="src short"><a href="#v:hRmTag">hRmTag</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> <a href="Data-HList-HList.html#t:HRmTag">HRmTag</a> as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs'</li><li class="src short"><a href="#v:hFlag">hFlag</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="Data-HList-HList.html#t:HAddTag">HAddTag</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a>)) as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs'</li><li class="src short"><span class="keyword">class</span> <a href="#t:HSplit">HSplit</a> l <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:HSplitT">HSplitT</a> l :: [*]</li><li><span class="keyword">type</span> <a href="#t:HSplitF">HSplitF</a> l :: [*]</li><li><a href="#v:hSplit">hSplit</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; (<a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HSplitT">HSplitT</a> l), <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HSplitF">HSplitF</a> l))</li></ul></li></ul></div><div id="interface"><h1 id="g:1">Heterogeneous type sequences</h1><div class="doc"><p>The easiest way to ensure that sequences can only be formed with Nil
 and Cons is to use GADTs
 The kind [*] is list kind (lists lifted to types)</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HList" class="def">HList</a> l <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HList" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HNil" class="def">HNil</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> []</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:HCons" class="def">HCons</a> ::  e -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (e : l) <span class="fixity">infixr 2</span><span class="rightedge"></span></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HList" class="caption collapser" onclick="toggleSection('i:HList')">Instances</p><div id="section.i:HList" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> * e1 e b, <a href="Data-HList-HTypeIndexed.html#t:HDeleteManyCase">HDeleteManyCase</a> * b e1 e l l1) =&gt; <a href="Data-HList-HListPrelude.html#t:HDeleteMany">HDeleteMany</a> * e1 (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l)) (<a href="Data-HList-HList.html#t:HList">HList</a> l1)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HDeleteMany">HDeleteMany</a> k e (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *)) (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-HListPrelude.html#t:HOccurs">HOccurs</a> e l, <a href="Data-HList-HListPrelude.html#t:HProject">HProject</a> l (<a href="Data-HList-HList.html#t:HList">HList</a> l')) =&gt; <a href="Data-HList-HListPrelude.html#t:HProject">HProject</a> l (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l'))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-HOccurs.html#t:HOccurrence">HOccurrence</a> e ((:) * x y) l', <a href="Data-HList-HOccurs.html#t:HOccurs-39-">HOccurs'</a> e l') =&gt; <a href="Data-HList-HListPrelude.html#t:HOccurs">HOccurs</a> e (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * x y))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HExtend">HExtend</a> e (<a href="Data-HList-HList.html#t:HList">HList</a> l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~) [*] l' (<a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> * l ([] *)) =&gt; <a href="Data-HList-HList.html#t:HBuild-39-">HBuild'</a> l (<a href="Data-HList-HList.html#t:HList">HList</a> l')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-HList.html#t:ConvHList">ConvHList</a> l, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Data-HList-HList.html#t:Prime">Prime</a> l)) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Data-HList-HList.html#t:HList">HList</a> l)</td><td class="doc"><p>this comparison is two traversals</p></td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Data.html#t:Data">Data</a> x, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Data.html#t:Data">Data</a> (<a href="Data-HList-HList.html#t:HList">HList</a> xs), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> * (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * x xs)), TypeablePolyK [*] ((:) * x xs)) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Data.html#t:Data">Data</a> (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * x xs))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">TypeablePolyK [*] ([] *) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Data.html#t:Data">Data</a> (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> e, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-HList.html#t:HList">HList</a> l)) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HProject">HProject</a> (<a href="Data-HList-HList.html#t:HList">HList</a> l) (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HAppend">HAppend</a> (<a href="Data-HList-HList.html#t:HList">HList</a> l1) (<a href="Data-HList-HList.html#t:HList">HList</a> l2)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f e e' =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:MapCar">MapCar</a> f) (e, <a href="Data-HList-HList.html#t:HList">HList</a> l) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e' l))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> ([*] -&gt; *) <a href="Data-HList-HList.html#t:HList">HList</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> l, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)) =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * ch (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Data-HList-FakePrelude.html#t:HBoolEQ">HBoolEQ</a> sel (<a href="Data-HList-HArray.html#t:KMember">KMember</a> n ns))), <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (ch, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)) =&gt; <a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *), n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * x y)) z, <a href="Data-HList-HZip.html#t:HZip3">HZip3</a> xs ys zs) =&gt; <a href="Data-HList-HZip.html#t:HZip3">HZip3</a> ((:) * x xs) ((:) * (<a href="Data-HList-HList.html#t:HList">HList</a> y) ys) ((:) * z zs)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HListPrelude.html#t:HExtendR">HExtendR</a> e (<a href="Data-HList-HList.html#t:HList">HList</a> l) = <a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HListPrelude.html#t:HAppendR">HAppendR</a> * (<a href="Data-HList-HList.html#t:HList">HList</a> l1) (<a href="Data-HList-HList.html#t:HList">HList</a> l2) = <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> * l1 l2)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:UnHList">UnHList</a> (<a href="Data-HList-HList.html#t:HList">HList</a> a) = a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n) = <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> l, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a>, <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n) = <a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> (e, (<a href="Data-HList-HList.html#t:HList">HList</a> l, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n) = <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Data-HList-FakePrelude.html#t:HBoolEQ">HBoolEQ</a> sel (<a href="Data-HList-HArray.html#t:KMember">KMember</a> n ns)), <a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> (<a href="Data-HList-HArray.html#t:FHUProj">FHUProj</a> sel ns) (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *), n) = <a href="Data-HList-FakePrelude.html#t:HNothing">HNothing</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:2">Alternative representation</h2><div class="doc"><p>HNil' and HCons' are the older ADT-style. This has some advantages
over the GADT:</p><ul><li>lazy pattern matches are allowed</li><li>type inference is better if you want to directly pattern match
<a href="http://stackoverflow.com/questions/19077037/is-there-any-deeper-type-theoretic-reason-ghc-cant-infer-this-type">see stackoverflow post here</a></li></ul></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HNil-39-" class="def">HNil'</a> <a href="src/Data-HList-HList.html#HNil%27" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HNil-39-" class="def">HNil'</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HNil-39-" class="caption collapser" onclick="toggleSection('i:HNil-39-')">Instances</p><div id="section.i:HNil-39-" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Data-HList-HList.html#t:HNil-39-">HNil'</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-Data.html#t:TypeRepsList">TypeRepsList</a> <a href="Data-HList-HList.html#t:HNil-39-">HNil'</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:UnPrime">UnPrime</a> <a href="Data-HList-HList.html#t:HNil-39-">HNil'</a> = [] *</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HCons-39-" class="def">HCons'</a> a b <a href="src/Data-HList-HList.html#HCons%27" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HCons-39-" class="def">HCons'</a> a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HCons-39-" class="caption collapser" onclick="toggleSection('i:HCons-39-')">Instances</p><div id="section.i:HCons-39-" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Data-HList-HList.html#t:HCons-39-">HCons'</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-Data.html#t:TypeRepsList">TypeRepsList</a> xs, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> * x) =&gt; <a href="Data-HList-Data.html#t:TypeRepsList">TypeRepsList</a> (<a href="Data-HList-HList.html#t:HCons-39-">HCons'</a> x xs)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:UnPrime">UnPrime</a> (<a href="Data-HList-HList.html#t:HCons-39-">HCons'</a> b bs) = (:) * b (<a href="Data-HList-HList.html#t:UnPrime">UnPrime</a> bs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Data-HList-HList.html#t:UnPrime">UnPrime</a> (<a href="Data-HList-HList.html#t:Prime">Prime</a> a) ~ a) =&gt; <a name="t:ConvHList" class="def">ConvHList</a> a <span class="keyword">where</span> <a href="src/Data-HList-HList.html#ConvHList" class="link">Source</a></p><div class="doc"><p>conversion between GADT (<code><a href="Data-HList-HList.html#t:HList">HList</a></code>) and ADT (<code><a href="Data-HList-HList.html#t:HNil-39-">HNil'</a></code> <code><a href="Data-HList-HList.html#t:HCons-39-">HCons'</a></code>)
 representations</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:Prime" class="def">Prime</a> a :: * <a href="src/Data-HList-HList.html#Prime" class="link">Source</a></p><p class="src"><span class="keyword">type</span> <a name="t:UnPrime" class="def">UnPrime</a> b :: [*] <a href="src/Data-HList-HList.html#UnPrime" class="link">Source</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:prime" class="def">prime</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> a -&gt; <a href="Data-HList-HList.html#t:Prime">Prime</a> a <a href="src/Data-HList-HList.html#prime" class="link">Source</a></p><p class="src"><a name="v:unPrime" class="def">unPrime</a> :: <a href="Data-HList-HList.html#t:Prime">Prime</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> a <a href="src/Data-HList-HList.html#unPrime" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ConvHList" class="caption collapser" onclick="toggleSection('i:ConvHList')">Instances</p><div id="section.i:ConvHList" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:ConvHList">ConvHList</a> ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:ConvHList">ConvHList</a> as =&gt; <a href="Data-HList-HList.html#t:ConvHList">ConvHList</a> ((:) * a as)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Basic list functions</h1><div class="top"><p class="src"><a name="v:hHead" class="def">hHead</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> (e : l) -&gt; e <a href="src/Data-HList-HList.html#hHead" class="link">Source</a></p><div class="doc"><p><code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:head">head</a></code></p></div></div><div class="top"><p class="src"><a name="v:hTail" class="def">hTail</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> (e : l) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l <a href="src/Data-HList-HList.html#hTail" class="link">Source</a></p><div class="doc"><p><code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:tail">tail</a></code></p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HLength" class="def">HLength</a> x :: <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> <a href="src/Data-HList-HList.html#HLength" class="link">Source</a></p><div class="doc"><p>Length</p></div><div class="subs instances"><p id="control.i:HLength" class="caption collapser" onclick="toggleSection('i:HLength')">Instances</p><div id="section.i:HLength" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HLength">HLength</a> k ([] k) = <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HLength">HLength</a> k ((:) k x xs) = <a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> (<a href="Data-HList-HList.html#t:HLength">HLength</a> k xs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hLength" class="def">hLength</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-HList.html#t:HLength">HLength</a> l) <a href="src/Data-HList-HList.html#hLength" class="link">Source</a></p></div><h2 id="g:4">Append</h2><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HAppendList" class="def">HAppendList</a> l1 l2 :: [k] <a href="src/Data-HList-HList.html#HAppendList" class="link">Source</a></p><div class="subs instances"><p id="control.i:HAppendList" class="caption collapser" onclick="toggleSection('i:HAppendList')">Instances</p><div id="section.i:HAppendList" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> k ([] k) l = l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> k ((:) k e l) l' = (:) k e (<a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> k l l')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hAppendList" class="def">hAppendList</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> l1 l2) <a href="src/Data-HList-HList.html#hAppendList" class="link">Source</a></p><div class="doc"><p>the same as <code><a href="Data-HList-HListPrelude.html#v:hAppend">hAppend</a></code></p></div></div><h2 id="g:5">Alternative append</h2><div class="top"><p class="src"><a name="v:append-39-" class="def">append'</a> ::  [a] -&gt; [a] -&gt; [a] <a href="src/Data-HList-HList.html#append%27" class="link">Source</a></p><div class="doc"><p><code><a href="Data-HList-HList.html#v:hAppend-39-">hAppend'</a></code> below is implemented using the same idea</p></div></div><div class="top"><p class="src"><a name="v:hAppend-39-" class="def">hAppend'</a> :: <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> <a href="Data-HList-HList.html#t:FHCons">FHCons</a> v l r =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; v -&gt; r <a href="src/Data-HList-HList.html#hAppend%27" class="link">Source</a></p><div class="doc"><p>Alternative implementation of <code><a href="Data-HList-HListPrelude.html#v:hAppend">hAppend</a></code>. Demonstrates <code><a href="Data-HList-HList.html#t:HFoldr">HFoldr</a></code></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:FHCons" class="def">FHCons</a> <a href="src/Data-HList-HList.html#FHCons" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:FHCons" class="def">FHCons</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:FHCons" class="caption collapser" onclick="toggleSection('i:FHCons')">Instances</p><div id="section.i:FHCons" class="show"><table><tr><td class="src">((~) * x (e, <a href="Data-HList-HList.html#t:HList">HList</a> l), (~) * y (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e l))) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HList.html#t:FHCons">FHCons</a> x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:6">Historical append</h2><div class="doc"><p>The original HList code is included below. In both cases
we had to program the algorithm twice, at the term and the type levels.</p><dl><dt><code>The class HAppend</code></dt><dd></dd></dl><pre>class HAppend l l' l'' | l l' -&gt; l''
 where
  hAppend :: l -&gt; l' -&gt; l''
</pre><dl><dt><code>The instance following the normal append</code></dt><dd></dd></dl><pre>instance HList l =&gt; HAppend HNil l l
 where
  hAppend HNil l = l

instance (HList l, HAppend l l' l'')
      =&gt; HAppend (HCons x l) l' (HCons x l'')
 where
  hAppend (HCons x l) l' = HCons x (hAppend l l')</pre></div><h1 id="g:7">Reversing HLists</h1><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HRevApp" class="def">HRevApp</a> l1 l2 :: [k] <a href="src/Data-HList-HList.html#HRevApp" class="link">Source</a></p><div class="subs instances"><p id="control.i:HRevApp" class="caption collapser" onclick="toggleSection('i:HRevApp')">Instances</p><div id="section.i:HRevApp" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> k ([] k) l = l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> k ((:) k e l) l' = <a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> k l ((:) k e l')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hRevApp" class="def">hRevApp</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> l1 l2) <a href="src/Data-HList-HList.html#hRevApp" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:hReverse" class="def">hReverse</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> * l1 ([] *)) <a href="src/Data-HList-HList.html#hReverse" class="link">Source</a></p></div><h1 id="g:8">A nicer notation for lists</h1><div class="top"><p class="src"><a name="v:hEnd" class="def">hEnd</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l <a href="src/Data-HList-HList.html#hEnd" class="link">Source</a></p><div class="doc"><p>Note:</p><dl><dt><code>x :: HList a</code></dt><dd>means: <code>forall a. x :: HList a</code><dl><dt><code>hEnd x</code></dt><dd>means: <code>exists a. x :: HList a</code></dd></dl></dd></dl><p>List termination</p></div></div><div class="top"><p class="src"><a name="v:hBuild" class="def">hBuild</a> :: <a href="Data-HList-HList.html#t:HBuild-39-">HBuild'</a> [] r =&gt; r <a href="src/Data-HList-HList.html#hBuild" class="link">Source</a></p><div class="doc"><p>Building lists</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HBuild-39-" class="def">HBuild'</a> l r <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HBuild%27" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hBuild-39-" class="def">hBuild'</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; r <a href="src/Data-HList-HList.html#hBuild%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HBuild-39-" class="caption collapser" onclick="toggleSection('i:HBuild-39-')">Instances</p><div id="section.i:HBuild-39-" class="show"><table><tr><td class="src">(~) [*] l' (<a href="Data-HList-HList.html#t:HRevApp">HRevApp</a> * l ([] *)) =&gt; <a href="Data-HList-HList.html#t:HBuild-39-">HBuild'</a> l (<a href="Data-HList-HList.html#t:HList">HList</a> l')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HBuild-39-">HBuild'</a> ((:) * a l) r =&gt; <a href="Data-HList-HList.html#t:HBuild-39-">HBuild'</a> l (a -&gt; r)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:9">examples</h2><div class="doc"><p>The classes above allow the third (shortest) way to make a list
(containing a,b,c) in this case</p><pre>list = a `HCons` b `HCons` c `HCons` HNil
list = a .*. b .*. c .*. HNil
list = hEnd $ hBuild a b c</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = hBuild True in hEnd x
</code></strong>H[True]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = hBuild True 'a' in hEnd x
</code></strong>H[True, 'a']
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = hBuild True 'a' &quot;ok&quot; in hEnd x
</code></strong>H[True, 'a', &quot;ok&quot;]
</pre></div><h3 id="g:10">historical</h3><div class="doc"><p>the show instance has since changed, but these uses of
'hBuild'/'hEnd' still work</p><pre>HList&gt; let x = hBuild True in hEnd x
HCons True HNil</pre><pre>HList&gt; let x = hBuild True 'a' in hEnd x
HCons True (HCons 'a' HNil)</pre><pre>HList&gt; let x = hBuild True 'a' &quot;ok&quot; in hEnd x
HCons True (HCons 'a' (HCons &quot;ok&quot; HNil))</pre><pre>HList&gt; hEnd (hBuild (Key 42) (Name &quot;Angus&quot;) Cow (Price 75.5))
HCons (Key 42) (HCons (Name &quot;Angus&quot;) (HCons Cow (HCons (Price 75.5) HNil)))</pre><pre>HList&gt; hEnd (hBuild (Key 42) (Name &quot;Angus&quot;) Cow (Price 75.5)) == angus
True</pre></div><h1 id="g:11">folds</h1><h2 id="g:12">foldr</h2><div class="doc"><p>Consume a heterogenous list. GADTs and type-classes mix well</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HFoldr" class="def">HFoldr</a> f v l r <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HFoldr" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hFoldr" class="def">hFoldr</a> :: f -&gt; v -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; r <a href="src/Data-HList-HList.html#hFoldr" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HFoldr" class="caption collapser" onclick="toggleSection('i:HFoldr')">Instances</p><div id="section.i:HFoldr" class="show"><table><tr><td class="src">(~) * v v' =&gt; <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> f v ([] *) v'</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f (e, r) r', <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> f v l r) =&gt; <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> f v ((:) * e l) r'</td><td class="doc"><p>uses <code><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a></code> not <code><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a></code></p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HScanr" class="def">HScanr</a> f z ls rs <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HScanr" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hScanr" class="def">hScanr</a> :: f -&gt; z -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> ls -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> rs <a href="src/Data-HList-HList.html#hScanr" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HScanr" class="caption collapser" onclick="toggleSection('i:HScanr')">Instances</p><div id="section.i:HScanr" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HScanr">HScanr</a> f z ([] *) ((:) * z ([] *))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f (x, r) s, <a href="Data-HList-HList.html#t:HScanr">HScanr</a> f z xs ((:) * r rs)) =&gt; <a href="Data-HList-HList.html#t:HScanr">HScanr</a> f z ((:) * x xs) ((:) * s ((:) * r rs))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HFoldr1" class="def">HFoldr1</a> f l r <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HFoldr1" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hFoldr1" class="def">hFoldr1</a> :: f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; r <a href="src/Data-HList-HList.html#hFoldr1" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HFoldr1" class="caption collapser" onclick="toggleSection('i:HFoldr1')">Instances</p><div id="section.i:HFoldr1" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f (e, r) r', <a href="Data-HList-HList.html#t:HFoldr1">HFoldr1</a> f ((:) * e' l) r) =&gt; <a href="Data-HList-HList.html#t:HFoldr1">HFoldr1</a> f ((:) * e ((:) * e' l)) r'</td><td class="doc"><p>uses <code><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a></code> not <code><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a></code></p></td></tr><tr><td class="src">(~) * v v' =&gt; <a href="Data-HList-HList.html#t:HFoldr1">HFoldr1</a> f ((:) * v ([] *)) v'</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:13">foldl</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HFoldl" class="def">HFoldl</a> f z xs r <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HFoldl" class="link">Source</a></p><div class="doc"><p>like <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:foldl">foldl</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hFoldl (uncurry $ flip (:)) [] (1 `HCons` 2 `HCons` HNil)
</code></strong>[2,1]
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hFoldl" class="def">hFoldl</a> :: f -&gt; z -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> xs -&gt; r <a href="src/Data-HList-HList.html#hFoldl" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HFoldl" class="caption collapser" onclick="toggleSection('i:HFoldl')">Instances</p><div id="section.i:HFoldl" class="show"><table><tr><td class="src">(~) * z z' =&gt; <a href="Data-HList-HList.html#t:HFoldl">HFoldl</a> f z ([] *) z'</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * zx (z, x), <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f zx z', <a href="Data-HList-HList.html#t:HFoldl">HFoldl</a> f z' xs r) =&gt; <a href="Data-HList-HList.html#t:HFoldl">HFoldl</a> f z ((:) * x xs) r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:14">unfold</h1><div class="doc"><p>Produce a heterogenous list. Uses the more limited
 <code><a href="Data-HList-FakePrelude.html#t:Apply">Apply</a></code> instead of <code>App</code> since that's all that is needed for uses of this
 function downstream. Those could in principle be re-written.</p></div><div class="top"><p class="src"><a name="v:hUnfold" class="def">hUnfold</a> :: (<a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> p s, <a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p (<a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> p s)) =&gt; p -&gt; s -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HUnfold">HUnfold</a> p s) <a href="src/Data-HList-HList.html#hUnfold" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:HUnfold" class="def">HUnfold</a> p s = <a href="Data-HList-HList.html#t:HUnfoldR">HUnfoldR</a> p (<a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> p s) <a href="src/Data-HList-HList.html#HUnfold" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HUnfold-39-" class="def">HUnfold'</a> p res <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HUnfold%27" class="link">Source</a></p><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:HUnfoldR" class="def">HUnfoldR</a> p res :: [*] <a href="src/Data-HList-HList.html#HUnfoldR" class="link">Source</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hUnfold-39-" class="def">hUnfold'</a> :: p -&gt; res -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HUnfoldR">HUnfoldR</a> p res) <a href="src/Data-HList-HList.html#hUnfold%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HUnfold-39-" class="caption collapser" onclick="toggleSection('i:HUnfold-39-')">Instances</p><div id="section.i:HUnfold-39-" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p <a href="Data-HList-FakePrelude.html#t:HNothing">HNothing</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:Apply">Apply</a> p s, <a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p (<a href="Data-HList-FakePrelude.html#t:ApplyR">ApplyR</a> p s)) =&gt; <a href="Data-HList-HList.html#t:HUnfold-39-">HUnfold'</a> p (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> (e, s))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:15">replicate</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Data-HList-HList.html#t:HLength">HLength</a> (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n e) ~ n) =&gt; <a name="t:HReplicate" class="def">HReplicate</a> n e <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HReplicate" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hReplicate" class="def">hReplicate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> n -&gt; e -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n e) <a href="src/Data-HList-HList.html#hReplicate" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HReplicate" class="caption collapser" onclick="toggleSection('i:HReplicate')">Instances</p><div id="section.i:HReplicate" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HReplicate">HReplicate</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> e</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HReplicate">HReplicate</a> n e =&gt; <a href="Data-HList-HList.html#t:HReplicate">HReplicate</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) e</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HReplicateR" class="def">HReplicateR</a> n e :: [k] <a href="src/Data-HList-HList.html#HReplicateR" class="link">Source</a></p><div class="doc"><p>would be associated with <code><a href="Data-HList-HList.html#t:HReplicate">HReplicate</a></code> except we want
 it to work with <code>e</code> of any kind, not just <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#v:-42-">*</a></code> that you can
 put into a HList. An &quot;inverse&quot; of <code><a href="Data-HList-HList.html#t:HLength">HLength</a></code></p></div><div class="subs instances"><p id="control.i:HReplicateR" class="caption collapser" onclick="toggleSection('i:HReplicateR')">Instances</p><div id="section.i:HReplicateR" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> k <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> e = [] k</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> k (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) e = (:) k e (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> k n e)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:16">concat</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HConcat" class="def">HConcat</a> a <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HConcat" class="link">Source</a></p><div class="doc"><p>Like <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:concat">concat</a></code> but for HLists of HLists.</p><p>Works in ghci... puzzling as what is different in doctest (it isn't
<code>-XExtendedDefaultRules</code>)</p><pre>hConcat $ hBuild (hBuild 1 2 3) (hBuild 'a' &quot;abc&quot;)</pre><p>H[1, 2, 3, <code>a</code>, &quot;abc&quot;]</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:HConcatR" class="def">HConcatR</a> a :: [*] <a href="src/Data-HList-HList.html#HConcatR" class="link">Source</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hConcat" class="def">hConcat</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HConcatR">HConcatR</a> a) <a href="src/Data-HList-HList.html#hConcat" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HConcat" class="caption collapser" onclick="toggleSection('i:HConcat')">Instances</p><div id="section.i:HConcat" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HConcat">HConcat</a> ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * x (<a href="Data-HList-HList.html#t:HList">HList</a> t), <a href="Data-HList-HList.html#t:HConcat">HConcat</a> xs) =&gt; <a href="Data-HList-HList.html#t:HConcat">HConcat</a> ((:) * x xs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:UnHList" class="def">UnHList</a> a :: [*] <a href="src/Data-HList-HList.html#UnHList" class="link">Source</a></p><div class="subs instances"><p id="control.i:UnHList" class="caption collapser" onclick="toggleSection('i:UnHList')">Instances</p><div id="section.i:UnHList" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:UnHList">UnHList</a> (<a href="Data-HList-HList.html#t:HList">HList</a> a) = a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:17">traversing HLists</h1><h2 id="g:18">producing HList</h2><h3 id="g:19">map</h3><div class="doc"><p>It could be implemented with <code><a href="Data-HList-HList.html#v:hFoldr">hFoldr</a></code>, as we show further below</p></div><div class="top"><p class="src"><a name="v:hMap" class="def">hMap</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f as' bs') =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs' <a href="src/Data-HList-HList.html#hMap" class="link">Source</a></p><div class="doc"><p>hMap is written such that the length of the result list
can be determined from the length of the argument list (and
the other way around). Similarly, the type of the elements
of the list is propagated in both directions too.</p><p>Excuse the ugly types printed. Unfortunately ghc (still?)
shows types like <code>'[a,b]</code> using the actual constructors involved
<code>(':) a ((':) b '[])</code> (or even worse when the kind variables are printed).</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XNoMonomorphismRestriction
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let xs = 1 .*. 'c' .*. HNil
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t hMap (HJust ()) xs
</code></strong>hMap (HJust ()) xs
  :: Num y =&gt; HList ((':) * (HJust y) ((':) * (HJust Char) ('[] *)))
</pre><p>These 4 examples show that the constraint on the length (2 in this cae)
can be applied before or after the <code><a href="Data-HList-HList.html#v:hMap">hMap</a></code>. That inference is independent of the
direction that type information is propagated for the individual elements.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let asLen2 xs = xs `asTypeOf` (undefined :: HList '[a,b])
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let lr xs = asLen2 (applyAB (HMap HRead) xs)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ls xs = asLen2 (applyAB (HMap HShow) xs)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let rl xs = applyAB (HMap HRead) (asLen2 xs)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sl xs = applyAB (HMap HShow) (asLen2 xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t lr
</code></strong>lr
  :: (Read y, Read y1) =&gt;
     HList ((':) * String ((':) * String ('[] *)))
     -&gt; HList ((':) * y ((':) * y1 ('[] *)))
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t rl
</code></strong>rl
  :: (Read y, Read y1) =&gt;
     HList ((':) * String ((':) * String ('[] *)))
     -&gt; HList ((':) * y ((':) * y1 ('[] *)))
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t ls
</code></strong>ls
  :: (Show y, Show y1) =&gt;
     HList ((':) * y ((':) * y1 ('[] *)))
     -&gt; HList ((':) * String ((':) * String ('[] *)))
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t sl
</code></strong>sl
  :: (Show y, Show y1) =&gt;
     HList ((':) * y ((':) * y1 ('[] *)))
     -&gt; HList ((':) * String ((':) * String ('[] *)))
</pre></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:HMap" class="def">HMap</a> f <a href="src/Data-HList-HList.html#HMap" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HMap" class="def">HMap</a> f</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HMap" class="caption collapser" onclick="toggleSection('i:HMap')">Instances</p><div id="section.i:HMap" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HMapCxt">HMapCxt</a> f as bs as' bs' =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:HMap">HMap</a> f) as bs</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:HMapCxt" class="def">HMapCxt</a> f as bs as' bs' = (<a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f as' bs', as ~ <a href="Data-HList-HList.html#t:HList">HList</a> as', bs ~ <a href="Data-HList-HList.html#t:HList">HList</a> bs', <a href="Data-HList-HList.html#t:SameLength">SameLength</a> as' bs') <a href="src/Data-HList-HList.html#HMapCxt" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:SameLength-39-" class="def">SameLength'</a> es1 es2 <a href="src/Data-HList-HList.html#SameLength%27" class="link">Source</a></p><div class="doc"><p>Ensure two lists have the same length. We do case analysis on the
 first one (hence the type must be known to the type checker).
 In contrast, the second list may be a type variable.</p></div><div class="subs instances"><p id="control.i:SameLength-39-" class="caption collapser" onclick="toggleSection('i:SameLength-39-')">Instances</p><div id="section.i:SameLength-39-" class="show"><table><tr><td class="src">(~) [k1] es2 ([] k1) =&gt; <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> k k ([] k) es2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> k k1 xs ys, (~) [k1] es2 ((:) k1 y ys)) =&gt; <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> k k ((:) k x xs) es2</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> x y, <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> y x) =&gt; <a name="t:SameLength" class="def">SameLength</a> x y <a href="src/Data-HList-HList.html#SameLength" class="link">Source</a></p><div class="doc"><p>symmetrical version of <code><a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a></code>. Written as a class instead of</p><pre>type SameLength a b = (SameLength' a b, SameLength' b a)</pre><p>since ghc expands type synonyms, but not classes (and it seems to have the same
result)</p></div><div class="subs instances"><p id="control.i:SameLength" class="caption collapser" onclick="toggleSection('i:SameLength')">Instances</p><div id="section.i:SameLength" class="show"><table><tr><td class="src">(<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> k1 k x y, <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> k k1 y x) =&gt; <a href="Data-HList-HList.html#t:SameLength">SameLength</a> k k x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HMapAux" class="def">HMapAux</a> f l r <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HMapAux" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hMapAux" class="def">hMapAux</a> :: <a href="Data-HList-HList.html#t:SameLength">SameLength</a> l r =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> r <a href="src/Data-HList-HList.html#hMapAux" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HMapAux" class="caption collapser" onclick="toggleSection('i:HMapAux')">Instances</p><div id="section.i:HMapAux" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f ([] *) ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f e e', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f l l', <a href="Data-HList-HList.html#t:SameLength">SameLength</a> * * l l') =&gt; <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> f ((:) * e l) ((:) * e' l')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h4 id="g:20">alternative implementation</h4><div class="doc"><p>currently broken</p></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:MapCar" class="def">MapCar</a> f <a href="src/Data-HList-HList.html#MapCar" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:MapCar" class="def">MapCar</a> f</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:MapCar" class="caption collapser" onclick="toggleSection('i:MapCar')">Instances</p><div id="section.i:MapCar" class="show"><table><tr><td class="src"><a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f e e' =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:MapCar">MapCar</a> f) (e, <a href="Data-HList-HList.html#t:HList">HList</a> l) (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * e' l))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hMapMapCar" class="def">hMapMapCar</a> :: <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> (<a href="Data-HList-HList.html#t:MapCar">MapCar</a> f) (<a href="Data-HList-HList.html#t:HList">HList</a> []) l l' =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; l' <a href="src/Data-HList-HList.html#hMapMapCar" class="link">Source</a></p><div class="doc"><p>Same as <code><a href="Data-HList-HList.html#v:hMap">hMap</a></code> only a different implementation.</p></div></div><h3 id="g:21"><code>appEndo . mconcat . map Endo</code></h3><div class="top"><p class="src"><a name="v:hComposeList" class="def">hComposeList</a> :: <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> <a href="Data-HList-FakePrelude.html#t:Comp">Comp</a> (a -&gt; a) l (t -&gt; a) =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; t -&gt; a <a href="src/Data-HList-HList.html#hComposeList" class="link">Source</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let xs = length .*. (+1) .*. (*2) .*. HNil
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hComposeList xs &quot;abc&quot;
</code></strong>8
</pre></div></div><h3 id="g:22">sequence</h3><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m, <a href="Data-HList-HList.html#t:SameLength">SameLength</a> a b) =&gt; <a name="t:HSequence" class="def">HSequence</a> m a b | a -&gt; b, m b -&gt; a <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HSequence" class="link">Source</a></p><div class="doc"><p>A heterogeneous version of</p><pre>sequenceA :: (Applicative m) =&gt; [m a] -&gt; m [a]</pre><p>Only now we operate on heterogeneous lists, where different elements
   may have different types <code>a</code>.
   In the argument list of monadic values (m a_i),
   although a_i may differ, the monad <code>m</code> must be the same for all
   elements. That's why we needed <a href="Data-HList-TypeCastGeneric2.html">Data.HList.TypeCastGeneric2</a> (currently (~)).
   The typechecker will complain
   if we attempt to use hSequence on a HList of monadic values with different
   monads.</p><p>The <code><a href="Data-HList-HList.html#v:hSequence">hSequence</a></code> problem was posed by Matthias Fischmann
   in his message on the Haskell-Cafe list on Oct 8, 2006</p><p><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/018708.html">http://www.haskell.org/pipermail/haskell-cafe/2006-October/018708.html</a></p><p><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/018784.html">http://www.haskell.org/pipermail/haskell-cafe/2006-October/018784.html</a></p><dl><dt><code>Maybe</code></dt><dd></dd></dl><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hSequence $ Just (1 :: Integer) `HCons` (Just 'c') `HCons` HNil
</code></strong>Just H[1, 'c']
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hSequence $  return 1 `HCons` Just  'c' `HCons` HNil
</code></strong>Just H[1, 'c']
</pre><dl><dt><code>List</code></dt><dd></dd></dl><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hSequence $ [1] `HCons` ['c'] `HCons` HNil
</code></strong>[H[1, 'c']]
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hSequence" class="def">hSequence</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> a -&gt; m (<a href="Data-HList-HList.html#t:HList">HList</a> b) <a href="src/Data-HList-HList.html#hSequence" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HSequence" class="caption collapser" onclick="toggleSection('i:HSequence')">Instances</p><div id="section.i:HSequence" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m =&gt; <a href="Data-HList-HList.html#t:HSequence">HSequence</a> m ([] *) ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) (* -&gt; *) m1 m, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m, <a href="Data-HList-HList.html#t:HSequence">HSequence</a> m as bs) =&gt; <a href="Data-HList-HList.html#t:HSequence">HSequence</a> m ((:) * (m1 a) as) ((:) * a bs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:LiftA2" class="def">LiftA2</a> f <a href="src/Data-HList-HList.html#LiftA2" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:LiftA2" class="def">LiftA2</a> f</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:LiftA2" class="caption collapser" onclick="toggleSection('i:LiftA2')">Instances</p><div id="section.i:LiftA2" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f (x, y) z, (~) * mz (m z), (~) * mxy (m x, m y), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:LiftA2">LiftA2</a> f) mxy mz</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h4 id="g:23">alternative implementation</h4><h2 id="g:24">producing homogenous lists</h2><h3 id="g:25">map (no sequencing)</h3><div class="doc"><p>This one we implement via hFoldr</p></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Mapcar" class="def">Mapcar</a> f <a href="src/Data-HList-HList.html#Mapcar" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Mapcar" class="def">Mapcar</a> f</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Mapcar" class="caption collapser" onclick="toggleSection('i:Mapcar')">Instances</p><div id="section.i:Mapcar" class="show"><table><tr><td class="src">((~) * l [e'], <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> f e e', (~) * el (e, l)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:Mapcar">Mapcar</a> f) el l</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:HMapOut" class="def">HMapOut</a> f l e = <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> (<a href="Data-HList-HList.html#t:Mapcar">Mapcar</a> f) [e] l [e] <a href="src/Data-HList-HList.html#HMapOut" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:hMapOut" class="def">hMapOut</a> :: <span class="keyword">forall</span> f e l. <a href="Data-HList-HList.html#t:HMapOut">HMapOut</a> f l e =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; [e] <a href="src/Data-HList-HList.html#hMapOut" class="link">Source</a></p></div><h3 id="g:26">mapM</h3><div class="top"><p class="src"><a name="v:hMapM" class="def">hMapM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-HList-HList.html#t:HMapOut">HMapOut</a> f l (m e)) =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; [m e] <a href="src/Data-HList-HList.html#hMapM" class="link">Source</a></p><div class="doc"><pre>mapM :: forall b m a. (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</pre><p>Likewise for mapM_.</p><p>See <code><a href="Data-HList-HList.html#v:hSequence">hSequence</a></code> if the result list should also be heterogenous.</p></div></div><div class="top"><p class="src"><a name="v:hMapM_" class="def">hMapM_</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-HList-HList.html#t:HMapOut">HMapOut</a> f l (m ())) =&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; m () <a href="src/Data-HList-HList.html#hMapM_" class="link">Source</a></p><div class="doc"><p>GHC doesn't like its own type.
 hMapM_  :: forall m a f e. (Monad m, HMapOut f a (m e)) =&gt; f -&gt; a -&gt; m ()
 Without explicit type signature, it's Ok. Sigh.
 Anyway, Hugs does insist on a better type. So we restrict as follows:</p></div></div><h1 id="g:27">Type-level equality for lists (<code><a href="Data-HList-FakePrelude.html#t:HEq">HEq</a></code>)</h1><h1 id="g:28">Ensure a list to contain HNats only</h1><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HNats" class="def">HNats</a> l :: [<a href="Data-HList-FakePrelude.html#t:HNat">HNat</a>] <a href="src/Data-HList-HList.html#HNats" class="link">Source</a></p><div class="doc"><p>We do so constructively, converting the HList whose elements
 are Proxy HNat to [HNat]. The latter kind is unpopulated and
 is present only at the type level.</p></div><div class="subs instances"><p id="control.i:HNats" class="caption collapser" onclick="toggleSection('i:HNats')">Instances</p><div id="section.i:HNats" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HNats">HNats</a> ([] *) = [] <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HNats">HNats</a> ((:) * (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n) l) = (:) <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> n (<a href="Data-HList-HList.html#t:HNats">HNats</a> l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hNats" class="def">hNats</a> ::  <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="Data-HList-HList.html#t:HNats">HNats</a> l) <a href="src/Data-HList-HList.html#hNats" class="link">Source</a></p></div><h1 id="g:29">Membership tests</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HMember" class="def">HMember</a> e1 l b | e1 l -&gt; b <a href="src/Data-HList-HList.html#HMember" class="link">Source</a></p><div class="doc"><p>Check to see if an HList contains an element with a given type
 This is a type-level only test</p></div><div class="subs instances"><p id="control.i:HMember" class="caption collapser" onclick="toggleSection('i:HMember')">Instances</p><div id="section.i:HMember" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HMember">HMember</a> k e1 ([] k) <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k e1 e b, <a href="Data-HList-HList.html#t:HMember-39-">HMember'</a> k b e1 l br) =&gt; <a href="Data-HList-HList.html#t:HMember">HMember</a> k e1 ((:) k e l) br</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HMember-39-" class="def">HMember'</a> b0 e1 l b | b0 e1 l -&gt; b <a href="src/Data-HList-HList.html#HMember%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:HMember-39-" class="caption collapser" onclick="toggleSection('i:HMember-39-')">Instances</p><div id="section.i:HMember-39-" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HMember">HMember</a> k e1 l br =&gt; <a href="Data-HList-HList.html#t:HMember-39-">HMember'</a> k <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a> e1 l br</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HMember-39-">HMember'</a> k <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a> e1 l <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HMemberP" class="def">HMemberP</a> pred e1 l :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="src/Data-HList-HList.html#HMemberP" class="link">Source</a></p><div class="subs instances"><p id="control.i:HMemberP" class="caption collapser" onclick="toggleSection('i:HMemberP')">Instances</p><div id="section.i:HMemberP" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HMemberP">HMemberP</a> pred e1 ([] *) = <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HMemberP-39-" class="def">HMemberP'</a> pred e1 l pb :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="src/Data-HList-HList.html#HMemberP%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:HMemberP-39-" class="caption collapser" onclick="toggleSection('i:HMemberP-39-')">Instances</p><div id="section.i:HMemberP-39-" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HMemberP-39-">HMemberP'</a> pred e1 l (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a>) = <a href="Data-HList-HList.html#t:HMemberP">HMemberP</a> pred e1 l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HList.html#t:HMemberP-39-">HMemberP'</a> pred e1 l (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a>) = <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hMember" class="def">hMember</a> :: <a href="Data-HList-HList.html#t:HMember">HMember</a> e l b =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> b <a href="src/Data-HList-HList.html#hMember" class="link">Source</a></p></div><h2 id="g:30">Another type-level membership test</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HMemberM" class="def">HMemberM</a> e1 l r | e1 l -&gt; r <a href="src/Data-HList-HList.html#HMemberM" class="link">Source</a></p><div class="doc"><p>Check to see if an element e occurs in a list l
 If not, return 'Nothing
 If the element does occur, return 'Just l1
 where l1 is a type-level list without e</p></div><div class="subs instances"><p id="control.i:HMemberM" class="caption collapser" onclick="toggleSection('i:HMemberM')">Instances</p><div id="section.i:HMemberM" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HMemberM">HMemberM</a> k e1 ([] k) (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a> [k])</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k e1 e b, <a href="Data-HList-HList.html#t:HMemberM1">HMemberM1</a> k b e1 ((:) k e l) res) =&gt; <a href="Data-HList-HList.html#t:HMemberM">HMemberM</a> k e1 ((:) k e l) res</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HMemberM1" class="def">HMemberM1</a> b e1 l r | b e1 l -&gt; r <a href="src/Data-HList-HList.html#HMemberM1" class="link">Source</a></p><div class="subs instances"><p id="control.i:HMemberM1" class="caption collapser" onclick="toggleSection('i:HMemberM1')">Instances</p><div id="section.i:HMemberM1" class="show"><table><tr><td class="src">(<a href="Data-HList-HList.html#t:HMemberM">HMemberM</a> k e1 l r, <a href="Data-HList-HList.html#t:HMemberM2">HMemberM2</a> k r e1 ((:) k e l) res) =&gt; <a href="Data-HList-HList.html#t:HMemberM1">HMemberM1</a> k <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a> e1 ((:) k e l) res</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HMemberM1">HMemberM1</a> k <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a> e1 ((:) k e l) (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#v:Just">Just</a> [k] l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HMemberM2" class="def">HMemberM2</a> b e1 l r | b e1 l -&gt; r <a href="src/Data-HList-HList.html#HMemberM2" class="link">Source</a></p><div class="subs instances"><p id="control.i:HMemberM2" class="caption collapser" onclick="toggleSection('i:HMemberM2')">Instances</p><div id="section.i:HMemberM2" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HMemberM2">HMemberM2</a> k (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a> [k]) e1 l (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a> [k])</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HMemberM2">HMemberM2</a> k (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#v:Just">Just</a> [k] l1) e1 ((:) k e l) (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#v:Just">Just</a> [k] ((:) k e l1))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:31">Staged equality for lists</h1><div class="doc"><p>removed. use Typeable instead</p></div><h1 id="g:32">Find an element in a set based on HEq</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HFind" class="def">HFind</a> e l n | e l -&gt; n <a href="src/Data-HList-HList.html#HFind" class="link">Source</a></p><div class="doc"><p>It is a pure type-level operation</p></div><div class="subs instances"><p id="control.i:HFind" class="caption collapser" onclick="toggleSection('i:HFind')">Instances</p><div id="section.i:HFind" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k e1 e2 b, <a href="Data-HList-HList.html#t:HFind-39-">HFind'</a> k b e1 l n) =&gt; <a href="Data-HList-HList.html#t:HFind">HFind</a> k e1 ((:) k e2 l) n</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HFind-39-" class="def">HFind'</a> b e l n | b e l -&gt; n <a href="src/Data-HList-HList.html#HFind%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:HFind-39-" class="caption collapser" onclick="toggleSection('i:HFind-39-')">Instances</p><div id="section.i:HFind-39-" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HFind-39-">HFind'</a> k <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a> e l <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HFind">HFind</a> k e l n =&gt; <a href="Data-HList-HList.html#t:HFind-39-">HFind'</a> k <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a> e l (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:33">Membership test based on type equality</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HTMember" class="def">HTMember</a> e l b | e l -&gt; b <a href="src/Data-HList-HList.html#HTMember" class="link">Source</a></p><div class="doc"><p>could be an associated type if HEq had one</p></div><div class="subs instances"><p id="control.i:HTMember" class="caption collapser" onclick="toggleSection('i:HTMember')">Instances</p><div id="section.i:HTMember" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HTMember">HTMember</a> k e ([] *) <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> * e e' b, <a href="Data-HList-HList.html#t:HTMember">HTMember</a> * e l b', (~) <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Data-HList-FakePrelude.html#t:HOr">HOr</a> b b') b'') =&gt; <a href="Data-HList-HList.html#t:HTMember">HTMember</a> * e ((:) * e' l) b''</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hTMember" class="def">hTMember</a> :: <a href="Data-HList-HList.html#t:HTMember">HTMember</a> e l b =&gt; e -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> b <a href="src/Data-HList-HList.html#hTMember" class="link">Source</a></p></div><h1 id="g:34">Intersection based on HTMember</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HTIntersect" class="def">HTIntersect</a> l1 l2 l3 | l1 l2 -&gt; l3 <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HTIntersect" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hTIntersect" class="def">hTIntersect</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l3 <a href="src/Data-HList-HList.html#hTIntersect" class="link">Source</a></p><div class="doc"><p>Like <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:intersect">intersect</a></code></p></div></div><div class="subs instances"><p id="control.i:HTIntersect" class="caption collapser" onclick="toggleSection('i:HTIntersect')">Instances</p><div id="section.i:HTIntersect" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HTIntersect">HTIntersect</a> ([] *) l ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-HList.html#t:HTMember">HTMember</a> * h l1 b, <a href="Data-HList-HList.html#t:HTIntersectBool">HTIntersectBool</a> b h t l1 l2) =&gt; <a href="Data-HList-HList.html#t:HTIntersect">HTIntersect</a> ((:) * h t) l1 l2</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HTIntersectBool" class="def">HTIntersectBool</a> b h t l1 l2 | b h t l1 -&gt; l2 <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HTIntersectBool" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hTIntersectBool" class="def">hTIntersectBool</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> b -&gt; h -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> t -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l1 -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l2 <a href="src/Data-HList-HList.html#hTIntersectBool" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HTIntersectBool" class="caption collapser" onclick="toggleSection('i:HTIntersectBool')">Instances</p><div id="section.i:HTIntersectBool" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HTIntersect">HTIntersect</a> t l1 l2 =&gt; <a href="Data-HList-HList.html#t:HTIntersectBool">HTIntersectBool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a> h t l1 l2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HTIntersect">HTIntersect</a> t l1 l2 =&gt; <a href="Data-HList-HList.html#t:HTIntersectBool">HTIntersectBool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a> h t l1 ((:) * h l2)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:35">Turn a heterogeneous list into a homogeneous one</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HList2List" class="def">HList2List</a> l e <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HList2List" class="link">Source</a></p><div class="doc"><p>Same as <code>hMapOut Id</code></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hList2List" class="def">hList2List</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; [e] <a href="src/Data-HList-HList.html#hList2List" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HList2List" class="caption collapser" onclick="toggleSection('i:HList2List')">Instances</p><div id="section.i:HList2List" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HList2List">HList2List</a> ([] *) e</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HList2List">HList2List</a> l e =&gt; <a href="Data-HList-HList.html#t:HList2List">HList2List</a> ((:) * e l) e</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:36">With <code>HMaybe</code></h1><h2 id="g:37">Turn list in a list of justs</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToHJust" class="def">ToHJust</a> l l' | l -&gt; l', l' -&gt; l <span class="keyword">where</span> <a href="src/Data-HList-HList.html#ToHJust" class="link">Source</a></p><div class="doc"><p>the same as <code>map Just</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toHJust (2 .*. 'a' .*. HNil)
</code></strong>H[HJust 2, HJust 'a']
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toHJust2 (2 .*. 'a' .*. HNil)
</code></strong>H[HJust 2, HJust 'a']
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toHJust" class="def">toHJust</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l' <a href="src/Data-HList-HList.html#toHJust" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ToHJust" class="caption collapser" onclick="toggleSection('i:ToHJust')">Instances</p><div id="section.i:ToHJust" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:ToHJust">ToHJust</a> ([] *) ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:ToHJust">ToHJust</a> l l' =&gt; <a href="Data-HList-HList.html#t:ToHJust">ToHJust</a> ((:) * e l) ((:) * (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> e) l')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:toHJust2" class="def">toHJust2</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> ()) as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs' <a href="src/Data-HList-HList.html#toHJust2" class="link">Source</a></p><div class="doc"><p>alternative implementation. The Apply instance is in <a href="Data-HList-FakePrelude.html">Data.HList.FakePrelude</a>.
 A longer type could be inferred.
 toHJust2 :: (HMap' (HJust ()) a b) =&gt; HList a -&gt; HList b</p></div></div><h2 id="g:38">Extract justs from list of maybes</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:FromHJust" class="def">FromHJust</a> l <span class="keyword">where</span> <a href="src/Data-HList-HList.html#FromHJust" class="link">Source</a></p><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:FromHJustR" class="def">FromHJustR</a> l :: [*] <a href="src/Data-HList-HList.html#FromHJustR" class="link">Source</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:fromHJust" class="def">fromHJust</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:FromHJustR">FromHJustR</a> l) <a href="src/Data-HList-HList.html#fromHJust" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:FromHJust" class="caption collapser" onclick="toggleSection('i:FromHJust')">Instances</p><div id="section.i:FromHJust" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> l =&gt; <a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> ((:) * (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> e) l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> l =&gt; <a href="Data-HList-HList.html#t:FromHJust">FromHJust</a> ((:) * <a href="Data-HList-FakePrelude.html#t:HNothing">HNothing</a> l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h3 id="g:39">alternative implementation</h3><div class="top"><p class="src"><a name="v:fromHJust2" class="def">fromHJust2</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> <a href="Data-HList-HList.html#t:HFromJust">HFromJust</a> as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs' <a href="src/Data-HList-HList.html#fromHJust2" class="link">Source</a></p><div class="doc"><p>A longer type could be inferred.
 fromHJust2 :: (HMap' HFromJust a b) =&gt; HList a -&gt; HList b</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HFromJust" class="def">HFromJust</a> <a href="src/Data-HList-HList.html#HFromJust" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HFromJust" class="def">HFromJust</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HFromJust" class="caption collapser" onclick="toggleSection('i:HFromJust')">Instances</p><div id="section.i:HFromJust" class="show"><table><tr><td class="src">(~) * hJustA (<a href="Data-HList-FakePrelude.html#t:HJust">HJust</a> a) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HList.html#t:HFromJust">HFromJust</a> hJustA a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:40">Annotated lists</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HAddTag" class="def">HAddTag</a> t <a href="src/Data-HList-HList.html#HAddTag" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HAddTag" class="def">HAddTag</a> t</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HAddTag" class="caption collapser" onclick="toggleSection('i:HAddTag')">Instances</p><div id="section.i:HAddTag" class="show"><table><tr><td class="src">(~) * et (e, t) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="Data-HList-HList.html#t:HAddTag">HAddTag</a> t) e et</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HRmTag" class="def">HRmTag</a> <a href="src/Data-HList-HList.html#HRmTag" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HRmTag" class="def">HRmTag</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HRmTag" class="caption collapser" onclick="toggleSection('i:HRmTag')">Instances</p><div id="section.i:HRmTag" class="show"><table><tr><td class="src">(~) * e' e =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HList.html#t:HRmTag">HRmTag</a> (e, t) e'</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hAddTag" class="def">hAddTag</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="Data-HList-HList.html#t:HAddTag">HAddTag</a> t) as' bs') =&gt; t -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs' <a href="src/Data-HList-HList.html#hAddTag" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:hRmTag" class="def">hRmTag</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> <a href="Data-HList-HList.html#t:HRmTag">HRmTag</a> as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs' <a href="src/Data-HList-HList.html#hRmTag" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:hFlag" class="def">hFlag</a> :: (<a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * bs' as', <a href="Data-HList-HList.html#t:SameLength-39-">SameLength'</a> * * as' bs', <a href="Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="Data-HList-HList.html#t:HAddTag">HAddTag</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a>)) as' bs') =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> as' -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> bs' <a href="src/Data-HList-HList.html#hFlag" class="link">Source</a></p><div class="doc"><p>Annotate list with a type-level Boolean
 hFlag :: HMap' (HAddTag (Proxy True)) l r =&gt; HList l -&gt; HList r</p></div></div><h1 id="g:41">Splitting by HTrue and HFalse</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HSplit" class="def">HSplit</a> l <span class="keyword">where</span> <a href="src/Data-HList-HList.html#HSplit" class="link">Source</a></p><div class="doc"><p>Analogus to Data.List.<code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:partition">partition</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Tuple.html#v:snd">snd</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hSplit $ (2,hTrue) .*. (3,hTrue) .*. (1,hFalse) .*. HNil
</code></strong>(H[2, 3],H[1])
</pre><p>it might make more sense to instead have <code>LVPair Bool e</code>
 instead of <code>(e, Proxy Bool)</code> since the former has the same
 runtime representation as <code>e</code></p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:HSplitT" class="def">HSplitT</a> l :: [*] <a href="src/Data-HList-HList.html#HSplitT" class="link">Source</a></p><p class="src"><span class="keyword">type</span> <a name="t:HSplitF" class="def">HSplitF</a> l :: [*] <a href="src/Data-HList-HList.html#HSplitF" class="link">Source</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hSplit" class="def">hSplit</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> l -&gt; (<a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HSplitT">HSplitT</a> l), <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HSplitF">HSplitF</a> l)) <a href="src/Data-HList-HList.html#hSplit" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HSplit" class="caption collapser" onclick="toggleSection('i:HSplit')">Instances</p><div id="section.i:HSplit" class="show"><table><tr><td class="src"><a href="Data-HList-HList.html#t:HSplit">HSplit</a> ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HSplit">HSplit</a> l =&gt; <a href="Data-HList-HList.html#t:HSplit">HSplit</a> ((:) * (e, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a>) l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-HList.html#t:HSplit">HSplit</a> l =&gt; <a href="Data-HList-HList.html#t:HSplit">HSplit</a> ((:) * (e, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a>) l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>