<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data/HList/HList.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{- |
<a name="line-2"></a>   The HList library
<a name="line-3"></a>
<a name="line-4"></a>   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
<a name="line-5"></a>
<a name="line-6"></a>   Basic declarations for typeful heterogeneous lists.
<a name="line-7"></a>
<a name="line-8"></a>   Excuse the unstructured haddocks: while there are many declarations here
<a name="line-9"></a>   some are alternative implementations should be grouped, and the definitions
<a name="line-10"></a>   here are analgous to many list functions in the "Prelude".
<a name="line-11"></a> -}</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span> <span class='hs-keyword'>where</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>FakePrelude</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>HListPrelude</span>
<a name="line-17"></a>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>Applicative</span><span class='hs-layout'>,</span> <span class='hs-varid'>liftA2</span><span class='hs-layout'>,</span> <span class='hs-varid'>pure</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a>
<a name="line-21"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-22"></a><span class='hs-comment'>-- * Heterogeneous type sequences</span>
<a name="line-23"></a><span class='hs-comment'>-- $note</span>
<a name="line-24"></a><span class='hs-comment'>--</span>
<a name="line-25"></a><span class='hs-comment'>-- The easiest way to ensure that sequences can only be formed with Nil</span>
<a name="line-26"></a><span class='hs-comment'>-- and Cons is to use GADTs</span>
<a name="line-27"></a><span class='hs-comment'>-- The kind [*] is list kind (lists lifted to types)</span>
<a name="line-28"></a>
<a name="line-29"></a><a name="Eq"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-keyglyph'>::</span><span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-30"></a>    <span class='hs-conid'>HNil</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-31"></a>    <span class='hs-conid'>HCons</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-32"></a>
<a name="line-33"></a><a name="instance%20Eq%20(HList%20l)"></a><span class='hs-comment'>-- | this comparison is two traversals</span>
<a name="line-34"></a><a name="instance%20Eq%20(HList%20l)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConvHList</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Prime</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-35"></a>    <span class='hs-varid'>x</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prime</span> <span class='hs-varid'>x</span> <span class='hs-varop'>==</span> <span class='hs-varid'>prime</span> <span class='hs-varid'>y</span>
<a name="line-36"></a>
<a name="line-37"></a><a name="HNil'"></a><span class='hs-comment'>-- ** Alternative representation</span>
<a name="line-38"></a><a name="HNil'"></a><span class='hs-comment'>{- $note
<a name="line-39"></a>
<a name="line-40"></a>HNil' and HCons' are the older ADT-style. This has some advantages
<a name="line-41"></a>over the GADT:
<a name="line-42"></a>
<a name="line-43"></a>* lazy pattern matches are allowed
<a name="line-44"></a>
<a name="line-45"></a>* type inference is better if you want to directly pattern match
<a name="line-46"></a>&lt;<a href="http://stackoverflow.com/questions/19077037/is-there-any-deeper-type-theoretic-reason-ghc-cant-infer-this-type">http://stackoverflow.com/questions/19077037/is-there-any-deeper-type-theoretic-reason-ghc-cant-infer-this-type</a> see stackoverflow post here&gt;
<a name="line-47"></a>
<a name="line-48"></a>-}</span>
<a name="line-49"></a><a name="HNil'"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HNil'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil'</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-50"></a><a name="HCons'"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HCons'</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons'</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-51"></a>
<a name="line-52"></a>
<a name="line-53"></a><a name="ConvHList"></a><span class='hs-comment'>-- | conversion between GADT ('HList') and ADT ('HNil'' 'HCons'')</span>
<a name="line-54"></a><a name="ConvHList"></a><span class='hs-comment'>-- representations</span>
<a name="line-55"></a><a name="ConvHList"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnPrime</span> <span class='hs-layout'>(</span><span class='hs-conid'>Prime</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ConvHList</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-56"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Prime</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>*</span>
<a name="line-57"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>UnPrime</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-58"></a>    <span class='hs-varid'>prime</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Prime</span> <span class='hs-varid'>a</span>
<a name="line-59"></a>    <span class='hs-varid'>unPrime</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Prime</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>a</span>
<a name="line-60"></a>
<a name="line-61"></a><a name="instance%20ConvHList%20(a%20':%20as)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>ConvHList</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ConvHList</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-62"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Prime</span>   <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`HCons'`</span> <span class='hs-conid'>Prime</span> <span class='hs-keyword'>as</span>
<a name="line-63"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>UnPrime</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>`HCons'`</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>UnPrime</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-64"></a>    <span class='hs-varid'>prime</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>`HCons`</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`HCons'`</span> <span class='hs-varid'>prime</span> <span class='hs-keyword'>as</span>
<a name="line-65"></a>    <span class='hs-varid'>unPrime</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>`HCons'`</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>unPrime</span> <span class='hs-keyword'>as</span>
<a name="line-66"></a>
<a name="line-67"></a><a name="instance%20ConvHList%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>ConvHList</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-68"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Prime</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil'</span>
<a name="line-69"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>UnPrime</span> <span class='hs-conid'>HNil'</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-70"></a>    <span class='hs-varid'>prime</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil'</span>
<a name="line-71"></a>    <span class='hs-varid'>unPrime</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-72"></a>
<a name="line-73"></a>
<a name="line-74"></a>
<a name="line-75"></a>
<a name="line-76"></a><a name="instance%20Show%20(HList%20'%5b%5d)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-77"></a>    <span class='hs-varid'>show</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"H[]"</span>
<a name="line-78"></a>
<a name="line-79"></a><a name="instance%20Show%20(HList%20(e%20':%20l))"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-80"></a>    <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-chr'>'H'</span><span class='hs-conop'>:</span><span class='hs-chr'>'['</span><span class='hs-conop'>:</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>l</span>
<a name="line-81"></a>		       <span class='hs-keyword'>in</span> <span class='hs-str'>"H["</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> 
<a name="line-82"></a>			          <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>s</span> <span class='hs-varop'>==</span> <span class='hs-str'>"]"</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>else</span> <span class='hs-str'>", "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-83"></a>
<a name="line-84"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>2</span> <span class='hs-varop'>`HCons`</span>
<a name="line-85"></a>
<a name="line-86"></a>
<a name="line-87"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-88"></a><span class='hs-comment'>-- * Basic list functions</span>
<a name="line-89"></a>
<a name="line-90"></a><a name="hHead"></a><span class='hs-comment'>-- | 'head'</span>
<a name="line-91"></a><span class='hs-definition'>hHead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span>
<a name="line-92"></a><span class='hs-definition'>hHead</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<a name="line-93"></a>
<a name="line-94"></a><a name="hTail"></a><span class='hs-comment'>-- | 'tail'</span>
<a name="line-95"></a><span class='hs-definition'>hTail</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span>
<a name="line-96"></a><span class='hs-definition'>hTail</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-97"></a>
<a name="line-98"></a><span class='hs-comment'>-- | Length</span>
<a name="line-99"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HLength</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HNat</span>
<a name="line-100"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HLength</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HZero</span>
<a name="line-101"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HLength</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HSucc</span> <span class='hs-layout'>(</span><span class='hs-conid'>HLength</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<a name="line-102"></a>
<a name="line-103"></a><a name="hLength"></a><span class='hs-definition'>hLength</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proxy</span> <span class='hs-layout'>(</span><span class='hs-conid'>HLength</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-104"></a><span class='hs-definition'>hLength</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>undefined</span>
<a name="line-105"></a>
<a name="line-106"></a><a name="instance%20HExtend%20e%20(HList%20l)"></a><span class='hs-comment'>-- ** Append</span>
<a name="line-107"></a><a name="instance%20HExtend%20e%20(HList%20l)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HExtend</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-108"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HExtendR</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-109"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>.*.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span>
<a name="line-110"></a>
<a name="line-111"></a><a name="instance%20HAppend%20(HList%20l1)%20(HList%20l2)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HAppend</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-112"></a>  <span class='hs-varid'>hAppend</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hAppendList</span>
<a name="line-113"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HAppendR</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HAppendList</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span>
<a name="line-114"></a>
<a name="line-115"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HAppendList</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span>
<a name="line-116"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HAppendList</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-117"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HAppendList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>HAppendList</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span>
<a name="line-118"></a>
<a name="line-119"></a><a name="hAppendList"></a><span class='hs-comment'>-- | the same as 'hAppend'</span>
<a name="line-120"></a><span class='hs-definition'>hAppendList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HAppendList</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span>
<a name="line-121"></a><span class='hs-definition'>hAppendList</span> <span class='hs-conid'>HNil</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-122"></a><span class='hs-definition'>hAppendList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>hAppend</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span>
<a name="line-123"></a>
<a name="line-124"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-125"></a>
<a name="line-126"></a><span class='hs-comment'>-- ** Alternative append</span>
<a name="line-127"></a>
<a name="line-128"></a>
<a name="line-129"></a><a name="append'"></a><span class='hs-comment'>-- | 'hAppend'' below is implemented using the same idea</span>
<a name="line-130"></a><span class='hs-definition'>append'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-131"></a><span class='hs-definition'>append'</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span> <span class='hs-varid'>l</span>
<a name="line-132"></a>
<a name="line-133"></a><a name="hAppend'"></a><span class='hs-comment'>-- | Alternative implementation of 'hAppend'. Demonstrates 'HFoldr'</span>
<a name="line-134"></a><span class='hs-definition'>hAppend'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>HFoldr</span> <span class='hs-conid'>FHCons</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-135"></a><span class='hs-definition'>hAppend'</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hFoldr</span> <span class='hs-conid'>FHCons</span> <span class='hs-varid'>l'</span> <span class='hs-varid'>l</span>
<a name="line-136"></a>
<a name="line-137"></a><a name="FHCons"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FHCons</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FHCons</span>
<a name="line-138"></a>
<a name="line-139"></a><a name="instance%20ApplyAB%20FHCons%20x%20y"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-conid'>FHCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>  <span class='hs-keyword'>where</span>
<a name="line-140"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span>
<a name="line-141"></a>
<a name="line-142"></a>
<a name="line-143"></a><span class='hs-comment'>-- ** Historical append</span>
<a name="line-144"></a>
<a name="line-145"></a><span class='hs-comment'>{- $
<a name="line-146"></a>
<a name="line-147"></a>The original HList code is included below. In both cases
<a name="line-148"></a>we had to program the algorithm twice, at the term and the type levels.
<a name="line-149"></a>
<a name="line-150"></a>[@The class HAppend@]
<a name="line-151"></a>
<a name="line-152"></a>&gt; class HAppend l l' l'' | l l' -&gt; l''
<a name="line-153"></a>&gt;  where
<a name="line-154"></a>&gt;   hAppend :: l -&gt; l' -&gt; l''
<a name="line-155"></a>&gt;
<a name="line-156"></a>
<a name="line-157"></a>[@The instance following the normal append@]
<a name="line-158"></a>
<a name="line-159"></a>&gt; instance HList l =&gt; HAppend HNil l l
<a name="line-160"></a>&gt;  where
<a name="line-161"></a>&gt;   hAppend HNil l = l
<a name="line-162"></a>&gt;
<a name="line-163"></a>&gt; instance (HList l, HAppend l l' l'')
<a name="line-164"></a>&gt;       =&gt; HAppend (HCons x l) l' (HCons x l'')
<a name="line-165"></a>&gt;  where
<a name="line-166"></a>&gt;   hAppend (HCons x l) l' = HCons x (hAppend l l')
<a name="line-167"></a>
<a name="line-168"></a>-}</span>
<a name="line-169"></a>
<a name="line-170"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-171"></a><span class='hs-comment'>-- * Reversing HLists</span>
<a name="line-172"></a>
<a name="line-173"></a><span class='hs-comment'>-- Append the reversed l1 to l2</span>
<a name="line-174"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HRevApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span>
<a name="line-175"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HRevApp</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-176"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HRevApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HRevApp</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span>
<a name="line-177"></a>
<a name="line-178"></a><a name="hRevApp"></a><span class='hs-definition'>hRevApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HRevApp</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span>
<a name="line-179"></a><span class='hs-definition'>hRevApp</span> <span class='hs-conid'>HNil</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-180"></a><span class='hs-definition'>hRevApp</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hRevApp</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span>
<a name="line-181"></a>
<a name="line-182"></a><a name="hReverse"></a><span class='hs-definition'>hReverse</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hRevApp</span> <span class='hs-varid'>l</span> <span class='hs-conid'>HNil</span>
<a name="line-183"></a>
<a name="line-184"></a>
<a name="line-185"></a>
<a name="line-186"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-187"></a>
<a name="line-188"></a><span class='hs-comment'>--</span>
<a name="line-189"></a><span class='hs-comment'>-- * A nicer notation for lists</span>
<a name="line-190"></a><span class='hs-comment'>--</span>
<a name="line-191"></a>
<a name="line-192"></a>
<a name="line-193"></a><a name="hEnd"></a><span class='hs-comment'>-- | List termination</span>
<a name="line-194"></a><span class='hs-definition'>hEnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span>
<a name="line-195"></a><span class='hs-definition'>hEnd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-196"></a>
<a name="line-197"></a><span class='hs-comment'>{- ^
<a name="line-198"></a>   Note:
<a name="line-199"></a>
<a name="line-200"></a>        [@x :: HList a@] means: @forall a. x :: HList a@
<a name="line-201"></a>
<a name="line-202"></a>        [@hEnd x@] means: @exists a. x :: HList a@
<a name="line-203"></a>-}</span>
<a name="line-204"></a>
<a name="line-205"></a>
<a name="line-206"></a><span class='hs-comment'>-- |  Building lists</span>
<a name="line-207"></a>
<a name="line-208"></a><a name="hBuild"></a><span class='hs-definition'>hBuild</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>HBuild'</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>r</span>
<a name="line-209"></a><span class='hs-definition'>hBuild</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>hBuild'</span> <span class='hs-conid'>HNil</span>
<a name="line-210"></a>
<a name="line-211"></a><a name="HBuild'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HBuild'</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-212"></a>    <span class='hs-varid'>hBuild'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-213"></a>
<a name="line-214"></a><a name="instance%20HBuild'%20l%20(HList%20l')"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>l'</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HRevApp</span> <span class='hs-varid'>l</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-215"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HBuild'</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-216"></a>  <span class='hs-varid'>hBuild'</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hReverse</span> <span class='hs-varid'>l</span>
<a name="line-217"></a>
<a name="line-218"></a><a name="instance%20HBuild'%20l%20(a-%3er)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HBuild'</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<a name="line-219"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HBuild'</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-220"></a>  <span class='hs-varid'>hBuild'</span> <span class='hs-varid'>l</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hBuild'</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-221"></a>
<a name="line-222"></a><span class='hs-comment'>-- ** examples</span>
<a name="line-223"></a><span class='hs-comment'>{- $examplesNote
<a name="line-224"></a>
<a name="line-225"></a>The classes above allow the third (shortest) way to make a list
<a name="line-226"></a>(containing a,b,c) in this case
<a name="line-227"></a>
<a name="line-228"></a>&gt; list = a `HCons` b `HCons` c `HCons` HNil
<a name="line-229"></a>&gt; list = a .*. b .*. c .*. HNil
<a name="line-230"></a>&gt; list = hEnd $ hBuild a b c
<a name="line-231"></a>
<a name="line-232"></a>&gt;&gt;&gt; let x = hBuild True in hEnd x
<a name="line-233"></a>H[True]
<a name="line-234"></a>
<a name="line-235"></a>&gt;&gt;&gt; let x = hBuild True 'a' in hEnd x
<a name="line-236"></a>H[True, 'a']
<a name="line-237"></a>
<a name="line-238"></a>&gt;&gt;&gt; let x = hBuild True 'a' "ok" in hEnd x
<a name="line-239"></a>H[True, 'a', "ok"]
<a name="line-240"></a>
<a name="line-241"></a>-}</span>
<a name="line-242"></a>
<a name="line-243"></a><span class='hs-comment'>-- *** historical</span>
<a name="line-244"></a><span class='hs-comment'>{- $hbuild the show instance has since changed, but these uses of
<a name="line-245"></a>'hBuild'/'hEnd' still work
<a name="line-246"></a>
<a name="line-247"></a>&gt; HList&gt; let x = hBuild True in hEnd x
<a name="line-248"></a>&gt; HCons True HNil
<a name="line-249"></a>
<a name="line-250"></a>&gt; HList&gt; let x = hBuild True 'a' in hEnd x
<a name="line-251"></a>&gt; HCons True (HCons 'a' HNil)
<a name="line-252"></a>
<a name="line-253"></a>&gt; HList&gt; let x = hBuild True 'a' "ok" in hEnd x
<a name="line-254"></a>&gt; HCons True (HCons 'a' (HCons "ok" HNil))
<a name="line-255"></a>
<a name="line-256"></a>&gt; HList&gt; hEnd (hBuild (Key 42) (Name "Angus") Cow (Price 75.5))
<a name="line-257"></a>&gt; HCons (Key 42) (HCons (Name "Angus") (HCons Cow (HCons (Price 75.5) HNil)))
<a name="line-258"></a>
<a name="line-259"></a>&gt; HList&gt; hEnd (hBuild (Key 42) (Name "Angus") Cow (Price 75.5)) == angus
<a name="line-260"></a>&gt; True
<a name="line-261"></a>
<a name="line-262"></a>-}</span>
<a name="line-263"></a>
<a name="line-264"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-265"></a>
<a name="line-266"></a><span class='hs-comment'>-- * folds</span>
<a name="line-267"></a><span class='hs-comment'>-- ** foldr</span>
<a name="line-268"></a><span class='hs-comment'>-- $foldNote  Consume a heterogenous list. GADTs and type-classes mix well</span>
<a name="line-269"></a>
<a name="line-270"></a>
<a name="line-271"></a><a name="HFoldr"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HFoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>v</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-272"></a>    <span class='hs-varid'>hFoldr</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-273"></a>
<a name="line-274"></a><a name="instance%20HFoldr%20f%20v%20'%5b%5d%20v'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>v'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>v</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>v'</span> <span class='hs-keyword'>where</span>
<a name="line-275"></a>    <span class='hs-varid'>hFoldr</span>       <span class='hs-keyword'>_</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span>
<a name="line-276"></a>
<a name="line-277"></a><a name="instance%20HFoldr%20f%20v%20(e%20':%20l)%20r'"></a><span class='hs-comment'>-- | uses 'ApplyAB' not 'Apply'</span>
<a name="line-278"></a><a name="instance%20HFoldr%20f%20v%20(e%20':%20l)%20r'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>r'</span><span class='hs-layout'>,</span> <span class='hs-conid'>HFoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-279"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>v</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>r'</span> <span class='hs-keyword'>where</span>
<a name="line-280"></a>    <span class='hs-varid'>hFoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>v</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>hFoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>v</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-281"></a>
<a name="line-282"></a>
<a name="line-283"></a><a name="HScanr"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HScanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>ls</span> <span class='hs-varid'>rs</span> <span class='hs-keyword'>where</span>
<a name="line-284"></a>    <span class='hs-varid'>hScanr</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>ls</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>rs</span>
<a name="line-285"></a>
<a name="line-286"></a><a name="instance%20HScanr%20f%20z%20'%5b%5d%20'%5bz%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HScanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>z</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>where</span>
<a name="line-287"></a>    <span class='hs-varid'>hScanr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>z</span> <span class='hs-conid'>HNil</span>
<a name="line-288"></a>
<a name="line-289"></a><a name="instance%20HScanr%20f%20z%20(x%20':%20xs)%20(s%20':%20r%20':%20rs)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-conid'>HScanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HScanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>r</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-290"></a>    <span class='hs-varid'>hScanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-291"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>hScanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-292"></a>            <span class='hs-conid'>HCons</span> <span class='hs-varid'>r</span> <span class='hs-varid'>rs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>r</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>rs</span>
<a name="line-293"></a>
<a name="line-294"></a><a name="HFoldr1"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HFoldr1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-295"></a>    <span class='hs-varid'>hFoldr1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-296"></a>
<a name="line-297"></a><a name="instance%20HFoldr1%20f%20'%5bv%5d%20v'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>v'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFoldr1</span> <span class='hs-varid'>f</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>v'</span> <span class='hs-keyword'>where</span>
<a name="line-298"></a>    <span class='hs-varid'>hFoldr1</span>      <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span>
<a name="line-299"></a>
<a name="line-300"></a><a name="instance%20HFoldr1%20f%20(e%20':%20e'%20':%20l)%20r'"></a><span class='hs-comment'>-- | uses 'ApplyAB' not 'Apply'</span>
<a name="line-301"></a><a name="instance%20HFoldr1%20f%20(e%20':%20e'%20':%20l)%20r'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>r'</span><span class='hs-layout'>,</span> <span class='hs-conid'>HFoldr1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-302"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFoldr1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>r'</span> <span class='hs-keyword'>where</span>
<a name="line-303"></a>    <span class='hs-varid'>hFoldr1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>hFoldr1</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-304"></a>
<a name="line-305"></a>
<a name="line-306"></a><span class='hs-comment'>-- ** foldl</span>
<a name="line-307"></a>
<a name="line-308"></a><a name="HFoldl"></a><span class='hs-comment'>{- | like 'foldl'
<a name="line-309"></a>
<a name="line-310"></a>
<a name="line-311"></a>&gt;&gt;&gt; hFoldl (uncurry $ flip (:)) [] (1 `HCons` 2 `HCons` HNil)
<a name="line-312"></a>[2,1]
<a name="line-313"></a>
<a name="line-314"></a>
<a name="line-315"></a>-}</span>
<a name="line-316"></a><a name="HFoldl"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HFoldl</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>z</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-317"></a>    <span class='hs-varid'>hFoldl</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-318"></a>
<a name="line-319"></a><a name="instance%20HFoldl%20f%20z%20(x%20':%20xs)%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>z'</span> <span class='hs-varid'>r</span> <span class='hs-varid'>x</span> <span class='hs-varid'>zx</span> <span class='hs-varid'>xs</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>zx</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>z</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>zx</span> <span class='hs-varid'>z'</span><span class='hs-layout'>,</span> <span class='hs-conid'>HFoldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z'</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-320"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFoldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-321"></a>    <span class='hs-varid'>hFoldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hFoldl</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>z</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>z'</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-322"></a>
<a name="line-323"></a><a name="instance%20HFoldl%20f%20z%20'%5b%5d%20z'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>z</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>z'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFoldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>z'</span> <span class='hs-keyword'>where</span>
<a name="line-324"></a>    <span class='hs-varid'>hFoldl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-325"></a>
<a name="line-326"></a>
<a name="line-327"></a>
<a name="line-328"></a>
<a name="line-329"></a>
<a name="line-330"></a><span class='hs-comment'>-- * unfold</span>
<a name="line-331"></a><span class='hs-comment'>-- $unfoldNote Produce a heterogenous list. Uses the more limited</span>
<a name="line-332"></a><span class='hs-comment'>-- 'Apply' instead of 'App' since that's all that is needed for uses of this</span>
<a name="line-333"></a><span class='hs-comment'>-- function downstream. Those could in principle be re-written.</span>
<a name="line-334"></a>
<a name="line-335"></a><a name="hUnfold"></a><span class='hs-definition'>hUnfold</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Apply</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-conid'>HUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyR</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HUnfold</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-336"></a><span class='hs-definition'>hUnfold</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-337"></a>
<a name="line-338"></a><a name="HUnfold"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HUnfold</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HUnfoldR</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyR</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-339"></a>
<a name="line-340"></a><a name="HUnfold'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>res</span> <span class='hs-keyword'>where</span>
<a name="line-341"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>HUnfoldR</span> <span class='hs-varid'>p</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-342"></a>    <span class='hs-varid'>hUnfold'</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HUnfoldR</span> <span class='hs-varid'>p</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-343"></a>
<a name="line-344"></a><a name="instance%20HUnfold'%20p%20HNothing"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-conid'>HNothing</span> <span class='hs-keyword'>where</span>
<a name="line-345"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>HUnfoldR</span> <span class='hs-varid'>p</span> <span class='hs-conid'>HNothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-346"></a>    <span class='hs-varid'>hUnfold'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-347"></a>
<a name="line-348"></a><a name="instance%20HUnfold'%20p%20(HJust%20(e,s))"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Apply</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-conid'>HUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyR</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-349"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>HUnfoldR</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>HUnfold</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span>
<a name="line-350"></a>    <span class='hs-varid'>hUnfold'</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>hUnfold</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-351"></a>
<a name="line-352"></a>
<a name="line-353"></a><span class='hs-comment'>-- * replicate</span>
<a name="line-354"></a>
<a name="line-355"></a><a name="HReplicate"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>HLength</span> <span class='hs-layout'>(</span><span class='hs-conid'>HReplicateR</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-356"></a>      <span class='hs-conid'>HReplicate</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HNat</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>where</span>
<a name="line-357"></a>    <span class='hs-varid'>hReplicate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HReplicateR</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-358"></a>
<a name="line-359"></a><a name="instance%20HReplicate%20HZero%20e"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HReplicate</span> <span class='hs-conid'>HZero</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>where</span>
<a name="line-360"></a>    <span class='hs-varid'>hReplicate</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-361"></a>
<a name="line-362"></a><a name="instance%20HReplicate%20(HSucc%20n)%20e"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HReplicate</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HReplicate</span> <span class='hs-layout'>(</span><span class='hs-conid'>HSucc</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>where</span>
<a name="line-363"></a>    <span class='hs-varid'>hReplicate</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>hReplicate</span> <span class='hs-layout'>(</span><span class='hs-varid'>hPred</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-364"></a>
<a name="line-365"></a><span class='hs-comment'>-- | would be associated with 'HReplicate' except we want</span>
<a name="line-366"></a><span class='hs-comment'>-- it to work with `e` of any kind, not just `*` that you can</span>
<a name="line-367"></a><span class='hs-comment'>-- put into a HList. An \"inverse\" of 'HLength'</span>
<a name="line-368"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HReplicateR</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HNat</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span>
<a name="line-369"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HReplicateR</span> <span class='hs-conid'>HZero</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-370"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HReplicateR</span> <span class='hs-layout'>(</span><span class='hs-conid'>HSucc</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>HReplicateR</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-371"></a>
<a name="line-372"></a><span class='hs-comment'>-- * concat</span>
<a name="line-373"></a>
<a name="line-374"></a><a name="HConcat"></a><span class='hs-comment'>{- |
<a name="line-375"></a>
<a name="line-376"></a>Like 'concat' but for HLists of HLists.
<a name="line-377"></a>
<a name="line-378"></a>Works in ghci... puzzling as what is different in doctest (it isn't
<a name="line-379"></a>@-XExtendedDefaultRules@)
<a name="line-380"></a>
<a name="line-381"></a>&gt; hConcat $ hBuild (hBuild 1 2 3) (hBuild 'a' "abc")
<a name="line-382"></a>
<a name="line-383"></a>H[1, 2, 3, 'a', "abc"]
<a name="line-384"></a>
<a name="line-385"></a>
<a name="line-386"></a>-}</span>
<a name="line-387"></a><a name="HConcat"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HConcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-388"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>HConcatR</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-389"></a>    <span class='hs-varid'>hConcat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HConcatR</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-390"></a>
<a name="line-391"></a><a name="instance%20HConcat%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HConcat</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-392"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>HConcatR</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-393"></a>    <span class='hs-varid'>hConcat</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-394"></a>
<a name="line-395"></a><a name="instance%20HConcat%20(x%20':%20xs)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>HConcat</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HConcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-396"></a>    <span class='hs-keyword'>type</span> <span class='hs-conid'>HConcatR</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HAppendList</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnHList</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HConcatR</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<a name="line-397"></a>    <span class='hs-varid'>hConcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`hAppendList`</span> <span class='hs-varid'>hConcat</span> <span class='hs-varid'>xs</span>
<a name="line-398"></a>
<a name="line-399"></a>
<a name="line-400"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>UnHList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-401"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>UnHList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-402"></a>
<a name="line-403"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-404"></a><span class='hs-comment'>-- * traversing HLists</span>
<a name="line-405"></a>
<a name="line-406"></a><span class='hs-comment'>-- ** producing HList</span>
<a name="line-407"></a><span class='hs-comment'>-- *** map</span>
<a name="line-408"></a><span class='hs-comment'>-- $mapNote It could be implemented with 'hFoldr', as we show further below</span>
<a name="line-409"></a>
<a name="line-410"></a><span class='hs-comment'>{- | hMap is written such that the length of the result list
<a name="line-411"></a>can be determined from the length of the argument list (and
<a name="line-412"></a>the other way around). Similarly, the type of the elements
<a name="line-413"></a>of the list is propagated in both directions too.
<a name="line-414"></a>
<a name="line-415"></a>Excuse the ugly types printed. Unfortunately ghc (still?)
<a name="line-416"></a>shows types like @'[a,b]@ using the actual constructors involved
<a name="line-417"></a>@(':) a ((':) b '[])@ (or even worse when the kind variables are printed).
<a name="line-418"></a>
<a name="line-419"></a>&gt;&gt;&gt; :set -XNoMonomorphismRestriction
<a name="line-420"></a>&gt;&gt;&gt; let xs = 1 .*. 'c' .*. HNil
<a name="line-421"></a>&gt;&gt;&gt; :t hMap (HJust ()) xs
<a name="line-422"></a>hMap (HJust ()) xs
<a name="line-423"></a>  :: Num y =&gt; HList ((':) * (HJust y) ((':) * (HJust Char) ('[] *)))
<a name="line-424"></a>
<a name="line-425"></a>
<a name="line-426"></a>These 4 examples show that the constraint on the length (2 in this cae)
<a name="line-427"></a>can be applied before or after the 'hMap'. That inference is independent of the
<a name="line-428"></a>direction that type information is propagated for the individual elements.
<a name="line-429"></a>
<a name="line-430"></a>
<a name="line-431"></a>&gt;&gt;&gt; let asLen2 xs = xs `asTypeOf` (undefined :: HList '[a,b])
<a name="line-432"></a>
<a name="line-433"></a>&gt;&gt;&gt; let lr xs = asLen2 (applyAB (HMap HRead) xs)
<a name="line-434"></a>&gt;&gt;&gt; let ls xs = asLen2 (applyAB (HMap HShow) xs)
<a name="line-435"></a>&gt;&gt;&gt; let rl xs = applyAB (HMap HRead) (asLen2 xs)
<a name="line-436"></a>&gt;&gt;&gt; let sl xs = applyAB (HMap HShow) (asLen2 xs)
<a name="line-437"></a>
<a name="line-438"></a>
<a name="line-439"></a>&gt;&gt;&gt; :t lr
<a name="line-440"></a>lr
<a name="line-441"></a>  :: (Read y, Read y1) =&gt;
<a name="line-442"></a>     HList ((':) * String ((':) * String ('[] *)))
<a name="line-443"></a>     -&gt; HList ((':) * y ((':) * y1 ('[] *)))
<a name="line-444"></a>
<a name="line-445"></a>&gt;&gt;&gt; :t rl
<a name="line-446"></a>rl
<a name="line-447"></a>  :: (Read y, Read y1) =&gt;
<a name="line-448"></a>     HList ((':) * String ((':) * String ('[] *)))
<a name="line-449"></a>     -&gt; HList ((':) * y ((':) * y1 ('[] *)))
<a name="line-450"></a>
<a name="line-451"></a>
<a name="line-452"></a>&gt;&gt;&gt; :t ls
<a name="line-453"></a>ls
<a name="line-454"></a>  :: (Show y, Show y1) =&gt;
<a name="line-455"></a>     HList ((':) * y ((':) * y1 ('[] *)))
<a name="line-456"></a>     -&gt; HList ((':) * String ((':) * String ('[] *)))
<a name="line-457"></a>
<a name="line-458"></a>&gt;&gt;&gt; :t sl
<a name="line-459"></a>sl
<a name="line-460"></a>  :: (Show y, Show y1) =&gt;
<a name="line-461"></a>     HList ((':) * y ((':) * y1 ('[] *)))
<a name="line-462"></a>     -&gt; HList ((':) * String ((':) * String ('[] *)))
<a name="line-463"></a>
<a name="line-464"></a>-}</span>
<a name="line-465"></a>
<a name="line-466"></a><a name="hMap"></a><span class='hs-definition'>hMap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMap</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-467"></a>
<a name="line-468"></a><a name="HMap"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>HMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HMap</span> <span class='hs-varid'>f</span>
<a name="line-469"></a>
<a name="line-470"></a><a name="instance%20ApplyAB%20(HMap%20f)%20as%20bs"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMapCxt</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>as'</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMap</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>bs</span> <span class='hs-keyword'>where</span>
<a name="line-471"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMap</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hMapAux</span> <span class='hs-varid'>f</span>
<a name="line-472"></a>
<a name="line-473"></a><a name="HMapCxt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HMapCxt</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>as'</span> <span class='hs-varid'>bs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMapAux</span> <span class='hs-varid'>f</span> <span class='hs-varid'>as'</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>as'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>,</span>
<a name="line-474"></a>    <span class='hs-conid'>SameLength</span> <span class='hs-varid'>as'</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>)</span>
<a name="line-475"></a>
<a name="line-476"></a>
<a name="line-477"></a><a name="SameLength'"></a><span class='hs-comment'>-- | Ensure two lists have the same length. We do case analysis on the</span>
<a name="line-478"></a><a name="SameLength'"></a><span class='hs-comment'>-- first one (hence the type must be known to the type checker).</span>
<a name="line-479"></a><a name="SameLength'"></a><span class='hs-comment'>-- In contrast, the second list may be a type variable.</span>
<a name="line-480"></a><a name="SameLength'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>SameLength'</span> <span class='hs-layout'>(</span><span class='hs-varid'>es1</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>es2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>m</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-481"></a><a name="instance%20SameLength'%20'%5b%5d%20es2%20instance%20(SameLength'%20xs%20ys,%20es2%20~%20(y%20':%20ys))%20=%3e%20SameLength'%20(x%20':%20xs)%20es2%20%7b-%20%7c%20symmetrical%20version%20of%20'SameLength''.%20Written%20as%20a%20class%20instead%20of%20%3e%20type%20SameLength%20a%20b%20=%20(SameLength'%20a%20b,%20SameLength'%20b%20a)%20since%20ghc%20expands%20type%20synonyms,%20but%20not%20classes%20(and%20it%20seems%20to%20have%20the%20same%20result)%20-%7d%20class%20(SameLength'%20x%20y,%20SameLength'%20y%20x)%20=%3e%20SameLength%20(x%20::%20%5bk%5d)%20(y%20::%20%5bm%5d)%20instance%20(SameLength'%20x%20y,%20SameLength'%20y%20x)%20=%3e%20SameLength%20x%20y%20class%20HMapAux%20f%20(l%20::%20%5b*%5d)%20(r%20::%20%5b*%5d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>es2</span> <span class='hs-keyglyph'>~</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>SameLength'</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>es2</span>
<a name="line-482"></a><a name="instance%20SameLength'%20(x%20':%20xs)%20es2%20%7b-%20%7c%20symmetrical%20version%20of%20'SameLength''.%20Written%20as%20a%20class%20instead%20of%20%3e%20type%20SameLength%20a%20b%20=%20(SameLength'%20a%20b,%20SameLength'%20b%20a)%20since%20ghc%20expands%20type%20synonyms,%20but%20not%20classes%20(and%20it%20seems%20to%20have%20the%20same%20result)%20-%7d%20class%20(SameLength'%20x%20y,%20SameLength'%20y%20x)%20=%3e%20SameLength%20(x%20::%20%5bk%5d)%20(y%20::%20%5bm%5d)%20instance%20(SameLength'%20x%20y,%20SameLength'%20y%20x)%20=%3e%20SameLength%20x%20y%20class%20HMapAux%20f%20(l%20::%20%5b*%5d)%20(r%20::%20%5b*%5d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>SameLength'</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span><span class='hs-layout'>,</span> <span class='hs-varid'>es2</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>SameLength'</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>es2</span>
<a name="line-483"></a>
<a name="line-484"></a><a name="SameLength"></a><span class='hs-comment'>{- | symmetrical version of 'SameLength''. Written as a class instead of
<a name="line-485"></a>
<a name="line-486"></a> &gt; type SameLength a b = (SameLength' a b, SameLength' b a)
<a name="line-487"></a>
<a name="line-488"></a>since ghc expands type synonyms, but not classes (and it seems to have the same
<a name="line-489"></a>result)
<a name="line-490"></a>
<a name="line-491"></a>-}</span>
<a name="line-492"></a><a name="SameLength"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>SameLength'</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-conid'>SameLength'</span> <span class='hs-varid'>y</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-493"></a>        <span class='hs-conid'>SameLength</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>m</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-494"></a><a name="instance%20SameLength%20x%20y%20class%20HMapAux%20f%20(l%20::%20%5b*%5d)%20(r%20::%20%5b*%5d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>SameLength'</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-conid'>SameLength'</span> <span class='hs-varid'>y</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>SameLength</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-495"></a>
<a name="line-496"></a>
<a name="line-497"></a>
<a name="line-498"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HMapAux</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-499"></a>  <span class='hs-varid'>hMapAux</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SameLength</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>r</span>
<a name="line-500"></a>
<a name="line-501"></a><a name="instance%20HMapAux%20f%20'%5b%5d%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMapAux</span> <span class='hs-varid'>f</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-502"></a>  <span class='hs-varid'>hMapAux</span>       <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-503"></a>
<a name="line-504"></a><a name="instance%20HMapAux%20f%20(e%20':%20l)%20(e'%20':%20l')"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span><span class='hs-layout'>,</span> <span class='hs-conid'>HMapAux</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span><span class='hs-layout'>,</span> <span class='hs-conid'>SameLength</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span>
<a name="line-505"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HMapAux</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-506"></a>  <span class='hs-varid'>hMapAux</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`HCons`</span> <span class='hs-varid'>hMapAux</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span>
<a name="line-507"></a>
<a name="line-508"></a>
<a name="line-509"></a>
<a name="line-510"></a>
<a name="line-511"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-512"></a>
<a name="line-513"></a><span class='hs-comment'>-- **** alternative implementation</span>
<a name="line-514"></a><span class='hs-comment'>-- $note currently broken</span>
<a name="line-515"></a>
<a name="line-516"></a><a name="MapCar"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>MapCar</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MapCar</span> <span class='hs-varid'>f</span>
<a name="line-517"></a>
<a name="line-518"></a><a name="hMapMapCar"></a><span class='hs-comment'>-- | Same as 'hMap' only a different implementation.</span>
<a name="line-519"></a><span class='hs-definition'>hMapMapCar</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>HFoldr</span> <span class='hs-layout'>(</span><span class='hs-conid'>MapCar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-520"></a>    <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>l'</span>
<a name="line-521"></a><span class='hs-definition'>hMapMapCar</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hFoldr</span> <span class='hs-layout'>(</span><span class='hs-conid'>MapCar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-conid'>HNil</span>
<a name="line-522"></a>
<a name="line-523"></a><a name="instance%20ApplyAB%20(MapCar%20f)%20(e,HList%20l)%20(HList%20(e'%20':%20l))"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>MapCar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>HList</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-524"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>MapCar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
<a name="line-525"></a>
<a name="line-526"></a>
<a name="line-527"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-528"></a>
<a name="line-529"></a><a name="hComposeList"></a><span class='hs-comment'>-- *** @appEndo . mconcat . map Endo@</span>
<a name="line-530"></a><span class='hs-comment'>{- |
<a name="line-531"></a>
<a name="line-532"></a>&gt;&gt;&gt; let xs = length .*. (+1) .*. (*2) .*. HNil
<a name="line-533"></a>&gt;&gt;&gt; hComposeList xs "abc"
<a name="line-534"></a>8
<a name="line-535"></a>
<a name="line-536"></a>
<a name="line-537"></a>-}</span>
<a name="line-538"></a><span class='hs-definition'>hComposeList</span>
<a name="line-539"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>HFoldr</span> <span class='hs-conid'>Comp</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-540"></a><span class='hs-definition'>hComposeList</span> <span class='hs-varid'>fs</span> <span class='hs-varid'>v0</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hFoldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Comp</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`asTypeOf`</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>fs</span> <span class='hs-varid'>v0</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>r</span>
<a name="line-541"></a>
<a name="line-542"></a>
<a name="line-543"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-544"></a>
<a name="line-545"></a><span class='hs-comment'>-- *** sequence</span>
<a name="line-546"></a><span class='hs-comment'>{- |
<a name="line-547"></a>   A heterogeneous version of
<a name="line-548"></a>
<a name="line-549"></a>   &gt; sequenceA :: (Applicative m) =&gt; [m a] -&gt; m [a]
<a name="line-550"></a>
<a name="line-551"></a>   Only now we operate on heterogeneous lists, where different elements
<a name="line-552"></a>   may have different types 'a'.
<a name="line-553"></a>   In the argument list of monadic values (m a_i),
<a name="line-554"></a>   although a_i may differ, the monad 'm' must be the same for all
<a name="line-555"></a>   elements. That's why we needed "Data.HList.TypeCastGeneric2" (currently (~)).
<a name="line-556"></a>   The typechecker will complain
<a name="line-557"></a>   if we attempt to use hSequence on a HList of monadic values with different
<a name="line-558"></a>   monads.
<a name="line-559"></a>
<a name="line-560"></a>   The 'hSequence' problem was posed by Matthias Fischmann
<a name="line-561"></a>   in his message on the Haskell-Cafe list on Oct 8, 2006
<a name="line-562"></a>
<a name="line-563"></a>   &lt;<a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/018708.html">http://www.haskell.org/pipermail/haskell-cafe/2006-October/018708.html</a>&gt;
<a name="line-564"></a>
<a name="line-565"></a>   &lt;<a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/018784.html">http://www.haskell.org/pipermail/haskell-cafe/2006-October/018784.html</a>&gt;
<a name="line-566"></a> -}</span>
<a name="line-567"></a>
<a name="line-568"></a><a name="HSequence"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>SameLength</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HSequence</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-569"></a>    <span class='hs-varid'>hSequence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-570"></a><span class='hs-comment'>{- ^
<a name="line-571"></a>
<a name="line-572"></a>[@Maybe@]
<a name="line-573"></a>
<a name="line-574"></a>&gt;&gt;&gt; hSequence $ Just (1 :: Integer) `HCons` (Just 'c') `HCons` HNil
<a name="line-575"></a>Just H[1, 'c']
<a name="line-576"></a>
<a name="line-577"></a>&gt;&gt;&gt; hSequence $  return 1 `HCons` Just  'c' `HCons` HNil
<a name="line-578"></a>Just H[1, 'c']
<a name="line-579"></a>
<a name="line-580"></a>
<a name="line-581"></a>[@List@]
<a name="line-582"></a>
<a name="line-583"></a>&gt;&gt;&gt; hSequence $ [1] `HCons` ['c'] `HCons` HNil
<a name="line-584"></a>[H[1, 'c']]
<a name="line-585"></a>
<a name="line-586"></a>
<a name="line-587"></a>-}</span>
<a name="line-588"></a>
<a name="line-589"></a><a name="instance%20HSequence%20m%20'%5b%5d%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HSequence</span> <span class='hs-varid'>m</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-590"></a>    <span class='hs-varid'>hSequence</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>HNil</span>
<a name="line-591"></a>
<a name="line-592"></a><a name="instance%20HSequence%20m%20(m1%20a%20':%20as)%20(a%20':%20bs)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>m1</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>HSequence</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-593"></a>    <span class='hs-conid'>HSequence</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>m1</span> <span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-594"></a>    <span class='hs-varid'>hSequence</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>hSequence</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-595"></a>
<a name="line-596"></a><a name="LiftA2"></a><span class='hs-comment'>-- data ConsM = ConsM</span>
<a name="line-597"></a><a name="LiftA2"></a><span class='hs-comment'>-- consM = LiftA2 FHCons</span>
<a name="line-598"></a><a name="LiftA2"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>LiftA2</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LiftA2</span> <span class='hs-varid'>f</span>
<a name="line-599"></a>
<a name="line-600"></a><a name="instance%20ApplyAB%20(LiftA2%20f)%20mxy%20mz"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varid'>z</span><span class='hs-layout'>,</span> <span class='hs-varid'>mz</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>m</span> <span class='hs-varid'>z</span><span class='hs-layout'>,</span> <span class='hs-varid'>mxy</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>m</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>LiftA2</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>mxy</span> <span class='hs-varid'>mz</span> <span class='hs-keyword'>where</span>
<a name="line-601"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>LiftA2</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>xy</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-varid'>curry</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>`uncurry`</span> <span class='hs-varid'>xy</span>
<a name="line-602"></a>
<a name="line-603"></a><span class='hs-comment'>{-
<a name="line-604"></a>instance (m1 ~ m, Applicative m) =&gt; ApplyAB ConsM (m a, m1 (HList l)) (m (HList (a ': l)))  where
<a name="line-605"></a>{-
<a name="line-606"></a>    type ApplyB ConsM (m a, m1 (HList l)) = Just (m (HList (a ': l)))
<a name="line-607"></a>    type ApplyA ConsM (m (HList (a ': l))) = Just (m a, m (HList l))
<a name="line-608"></a>    -}
<a name="line-609"></a>    applyAB _ (me,ml) = liftA2 HCons me ml
<a name="line-610"></a>    -}</span>
<a name="line-611"></a>
<a name="line-612"></a>
<a name="line-613"></a><span class='hs-comment'>-- **** alternative implementation</span>
<a name="line-614"></a>
<a name="line-615"></a><span class='hs-comment'>-- | 'hSequence2' is not recommended over 'hSequence' since it possibly doesn't</span>
<a name="line-616"></a><span class='hs-comment'>-- allow inferring argument types from the result types. Otherwise this version</span>
<a name="line-617"></a><span class='hs-comment'>-- should do exactly the same thing.</span>
<a name="line-618"></a><span class='hs-comment'>--</span>
<a name="line-619"></a><span class='hs-comment'>-- The DataKinds version needs a little help to find the type of the</span>
<a name="line-620"></a><span class='hs-comment'>-- return HNil, unlike the original version, which worked just fine as</span>
<a name="line-621"></a><span class='hs-comment'>--</span>
<a name="line-622"></a><span class='hs-comment'>--  &gt; hSequence l = hFoldr ConsM (return HNil) l</span>
<a name="line-623"></a>
<a name="line-624"></a>
<a name="line-625"></a><span class='hs-comment'>{-
<a name="line-626"></a>hSequence2 :: HSequence2 l f a =&gt; HList l -&gt; f a
<a name="line-627"></a>hSequence2 l =
<a name="line-628"></a>    let rHNil = pure HNil `asTypeOf` (liftA undefined x)
<a name="line-629"></a>        x = hFoldr ConsM rHNil l
<a name="line-630"></a>    in x
<a name="line-631"></a>
<a name="line-632"></a>
<a name="line-633"></a>-- | abbreviation for the constraint on 'hSequence2'
<a name="line-634"></a>type HSequence2 l f a = (Applicative f, HFoldr ConsM (f (HList ('[]))) l (f a))
<a name="line-635"></a>-}</span>
<a name="line-636"></a>
<a name="line-637"></a>
<a name="line-638"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-639"></a>
<a name="line-640"></a>
<a name="line-641"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-642"></a><span class='hs-comment'>-- ** producing homogenous lists</span>
<a name="line-643"></a>
<a name="line-644"></a><span class='hs-comment'>-- *** map (no sequencing)</span>
<a name="line-645"></a><span class='hs-comment'>-- $mapOut This one we implement via hFoldr</span>
<a name="line-646"></a>
<a name="line-647"></a><a name="Mapcar"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Mapcar</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Mapcar</span> <span class='hs-varid'>f</span>
<a name="line-648"></a>
<a name="line-649"></a><a name="instance%20ApplyAB%20(Mapcar%20f)%20el%20l"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>~</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e'</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span><span class='hs-layout'>,</span> <span class='hs-varid'>el</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mapcar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>el</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>where</span>
<a name="line-650"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mapcar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyAB</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l</span>
<a name="line-651"></a>
<a name="line-652"></a><a name="HMapOut"></a><span class='hs-comment'>-- A synonym for the complex constraint</span>
<a name="line-653"></a><a name="HMapOut"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HMapOut</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>HFoldr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mapcar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-654"></a>
<a name="line-655"></a><a name="hMapOut"></a><span class='hs-definition'>hMapOut</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span><span class='hs-varop'>.</span> <span class='hs-conid'>HMapOut</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span>
<a name="line-656"></a><span class='hs-definition'>hMapOut</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hFoldr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mapcar</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
<a name="line-657"></a>
<a name="line-658"></a>
<a name="line-659"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-660"></a><span class='hs-comment'>-- *** mapM</span>
<a name="line-661"></a>
<a name="line-662"></a><span class='hs-comment'>-- |</span>
<a name="line-663"></a><span class='hs-comment'>--</span>
<a name="line-664"></a><span class='hs-comment'>-- &gt; mapM :: forall b m a. (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</span>
<a name="line-665"></a><span class='hs-comment'>--</span>
<a name="line-666"></a><span class='hs-comment'>-- Likewise for mapM_.</span>
<a name="line-667"></a><span class='hs-comment'>--</span>
<a name="line-668"></a><span class='hs-comment'>-- See 'hSequence' if the result list should also be heterogenous.</span>
<a name="line-669"></a>
<a name="line-670"></a><a name="hMapM"></a><span class='hs-definition'>hMapM</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>HMapOut</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>m</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span>
<a name="line-671"></a><span class='hs-definition'>hMapM</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>hMapOut</span> <span class='hs-varid'>f</span>
<a name="line-672"></a>
<a name="line-673"></a><a name="hMapM_"></a><span class='hs-comment'>-- | GHC doesn't like its own type.</span>
<a name="line-674"></a><span class='hs-comment'>-- hMapM_  :: forall m a f e. (Monad m, HMapOut f a (m e)) =&gt; f -&gt; a -&gt; m ()</span>
<a name="line-675"></a><span class='hs-comment'>-- Without explicit type signature, it's Ok. Sigh.</span>
<a name="line-676"></a><span class='hs-comment'>-- Anyway, Hugs does insist on a better type. So we restrict as follows:</span>
<a name="line-677"></a><span class='hs-comment'>--</span>
<a name="line-678"></a><span class='hs-definition'>hMapM_</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>HMapOut</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-679"></a><span class='hs-definition'>hMapM_</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>sequence_</span> <span class='hs-varop'>.</span>  <span class='hs-varid'>disambiguate</span> <span class='hs-varop'>.</span> <span class='hs-varid'>hMapM</span> <span class='hs-varid'>f</span>
<a name="line-680"></a> <span class='hs-keyword'>where</span>
<a name="line-681"></a>  <span class='hs-varid'>disambiguate</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>q</span> <span class='hs-conid'>()</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>q</span> <span class='hs-conid'>()</span><span class='hs-keyglyph'>]</span>
<a name="line-682"></a>  <span class='hs-varid'>disambiguate</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>id</span>
<a name="line-683"></a>
<a name="line-684"></a>
<a name="line-685"></a>
<a name="line-686"></a>
<a name="line-687"></a>
<a name="line-688"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-689"></a><span class='hs-comment'>-- * Type-level equality for lists ('HEq')</span>
<a name="line-690"></a>
<a name="line-691"></a><a name="instance%20HEq%20(e1%20':%20l1)%20(e2%20':%20l2)%20br%20--%20--------------------------------------------------------------------------%20--%20*%20Ensure%20a%20list%20to%20contain%20HNats%20only%20--%20%7c%20We%20do%20so%20constructively,%20converting%20the%20HList%20whose%20elements%20--%20are%20Proxy%20HNat%20to%20%5bHNat%5d.%20The%20latter%20kind%20is%20unpopulated%20and%20--%20is%20present%20only%20at%20the%20type%20level.%20type%20family%20HNats%20(l%20::%20%5b*%5d)%20::%20%5bHNat%5d%20type%20instance%20HNats%20'%5b%5d%20=%20'%5b%5d%20type%20instance%20HNats%20(Proxy%20n%20':%20l)%20=%20n%20':%20HNats%20l%20hNats%20::%20HList%20l%20-%3e%20Proxy%20(HNats%20l)%20hNats%20=%20undefined%20--%20--------------------------------------------------------------------------%20--%20*%20Membership%20tests%20--%20%7c%20Check%20to%20see%20if%20an%20HList%20contains%20an%20element%20with%20a%20given%20type%20--%20This%20is%20a%20type-level%20only%20test%20class%20HMember%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20e1%20l%20-%3e%20b%20instance%20HMember%20e1%20'%5b%5d%20False%20instance%20(HEq%20e1%20e%20b,%20HMember'%20b%20e1%20l%20br)%20=%3e%20HMember%20e1%20(e%20':%20l)%20br%20class%20HMember'%20(b0%20::%20Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20b0%20e1%20l%20-%3e%20b%20instance%20HMember'%20True%20e1%20l%20True%20instance%20(HMember%20e1%20l%20br)%20=%3e%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HEq</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>      <span class='hs-conid'>True</span>
<a name="line-692"></a><a name="instance%20HEq%20(e1%20':%20l1)%20(e2%20':%20l2)%20br%20--%20--------------------------------------------------------------------------%20--%20*%20Ensure%20a%20list%20to%20contain%20HNats%20only%20--%20%7c%20We%20do%20so%20constructively,%20converting%20the%20HList%20whose%20elements%20--%20are%20Proxy%20HNat%20to%20%5bHNat%5d.%20The%20latter%20kind%20is%20unpopulated%20and%20--%20is%20present%20only%20at%20the%20type%20level.%20type%20family%20HNats%20(l%20::%20%5b*%5d)%20::%20%5bHNat%5d%20type%20instance%20HNats%20'%5b%5d%20=%20'%5b%5d%20type%20instance%20HNats%20(Proxy%20n%20':%20l)%20=%20n%20':%20HNats%20l%20hNats%20::%20HList%20l%20-%3e%20Proxy%20(HNats%20l)%20hNats%20=%20undefined%20--%20--------------------------------------------------------------------------%20--%20*%20Membership%20tests%20--%20%7c%20Check%20to%20see%20if%20an%20HList%20contains%20an%20element%20with%20a%20given%20type%20--%20This%20is%20a%20type-level%20only%20test%20class%20HMember%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20e1%20l%20-%3e%20b%20instance%20HMember%20e1%20'%5b%5d%20False%20instance%20(HEq%20e1%20e%20b,%20HMember'%20b%20e1%20l%20br)%20=%3e%20HMember%20e1%20(e%20':%20l)%20br%20class%20HMember'%20(b0%20::%20Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20b0%20e1%20l%20-%3e%20b%20instance%20HMember'%20True%20e1%20l%20True%20instance%20(HMember%20e1%20l%20br)%20=%3e%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HEq</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-conid'>False</span>
<a name="line-693"></a><a name="instance%20HEq%20(e1%20':%20l1)%20(e2%20':%20l2)%20br%20--%20--------------------------------------------------------------------------%20--%20*%20Ensure%20a%20list%20to%20contain%20HNats%20only%20--%20%7c%20We%20do%20so%20constructively,%20converting%20the%20HList%20whose%20elements%20--%20are%20Proxy%20HNat%20to%20%5bHNat%5d.%20The%20latter%20kind%20is%20unpopulated%20and%20--%20is%20present%20only%20at%20the%20type%20level.%20type%20family%20HNats%20(l%20::%20%5b*%5d)%20::%20%5bHNat%5d%20type%20instance%20HNats%20'%5b%5d%20=%20'%5b%5d%20type%20instance%20HNats%20(Proxy%20n%20':%20l)%20=%20n%20':%20HNats%20l%20hNats%20::%20HList%20l%20-%3e%20Proxy%20(HNats%20l)%20hNats%20=%20undefined%20--%20--------------------------------------------------------------------------%20--%20*%20Membership%20tests%20--%20%7c%20Check%20to%20see%20if%20an%20HList%20contains%20an%20element%20with%20a%20given%20type%20--%20This%20is%20a%20type-level%20only%20test%20class%20HMember%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20e1%20l%20-%3e%20b%20instance%20HMember%20e1%20'%5b%5d%20False%20instance%20(HEq%20e1%20e%20b,%20HMember'%20b%20e1%20l%20br)%20=%3e%20HMember%20e1%20(e%20':%20l)%20br%20class%20HMember'%20(b0%20::%20Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20b0%20e1%20l%20-%3e%20b%20instance%20HMember'%20True%20e1%20l%20True%20instance%20(HMember%20e1%20l%20br)%20=%3e%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-conid'>False</span>
<a name="line-694"></a><a name="instance%20HEq%20(e1%20':%20l1)%20(e2%20':%20l2)%20br%20--%20--------------------------------------------------------------------------%20--%20*%20Ensure%20a%20list%20to%20contain%20HNats%20only%20--%20%7c%20We%20do%20so%20constructively,%20converting%20the%20HList%20whose%20elements%20--%20are%20Proxy%20HNat%20to%20%5bHNat%5d.%20The%20latter%20kind%20is%20unpopulated%20and%20--%20is%20present%20only%20at%20the%20type%20level.%20type%20family%20HNats%20(l%20::%20%5b*%5d)%20::%20%5bHNat%5d%20type%20instance%20HNats%20'%5b%5d%20=%20'%5b%5d%20type%20instance%20HNats%20(Proxy%20n%20':%20l)%20=%20n%20':%20HNats%20l%20hNats%20::%20HList%20l%20-%3e%20Proxy%20(HNats%20l)%20hNats%20=%20undefined%20--%20--------------------------------------------------------------------------%20--%20*%20Membership%20tests%20--%20%7c%20Check%20to%20see%20if%20an%20HList%20contains%20an%20element%20with%20a%20given%20type%20--%20This%20is%20a%20type-level%20only%20test%20class%20HMember%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20e1%20l%20-%3e%20b%20instance%20HMember%20e1%20'%5b%5d%20False%20instance%20(HEq%20e1%20e%20b,%20HMember'%20b%20e1%20l%20br)%20=%3e%20HMember%20e1%20(e%20':%20l)%20br%20class%20HMember'%20(b0%20::%20Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20b0%20e1%20l%20-%3e%20b%20instance%20HMember'%20True%20e1%20l%20True%20instance%20(HMember%20e1%20l%20br)%20=%3e%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span> <span class='hs-varid'>b1</span><span class='hs-layout'>,</span> <span class='hs-conid'>HEq</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>b2</span><span class='hs-layout'>,</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HAnd</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>b2</span><span class='hs-layout'>)</span>
<a name="line-695"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>e1</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e2</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-varid'>br</span>
<a name="line-696"></a>
<a name="line-697"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-698"></a><span class='hs-comment'>-- * Ensure a list to contain HNats only</span>
<a name="line-699"></a><span class='hs-comment'>-- | We do so constructively, converting the HList whose elements</span>
<a name="line-700"></a><span class='hs-comment'>-- are Proxy HNat to [HNat]. The latter kind is unpopulated and</span>
<a name="line-701"></a><span class='hs-comment'>-- is present only at the type level.</span>
<a name="line-702"></a>
<a name="line-703"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HNats</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>HNat</span><span class='hs-keyglyph'>]</span>
<a name="line-704"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HNats</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-705"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HNats</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proxy</span> <span class='hs-varid'>n</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>HNats</span> <span class='hs-varid'>l</span>
<a name="line-706"></a>
<a name="line-707"></a><a name="hNats"></a><span class='hs-definition'>hNats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proxy</span> <span class='hs-layout'>(</span><span class='hs-conid'>HNats</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-708"></a><span class='hs-definition'>hNats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<a name="line-709"></a>
<a name="line-710"></a>
<a name="line-711"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-712"></a><span class='hs-comment'>-- * Membership tests</span>
<a name="line-713"></a>
<a name="line-714"></a><span class='hs-comment'>-- | Check to see if an HList contains an element with a given type</span>
<a name="line-715"></a><span class='hs-comment'>-- This is a type-level only test</span>
<a name="line-716"></a>
<a name="line-717"></a><a name="HMember"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HMember</span> <span class='hs-layout'>(</span><span class='hs-varid'>e1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-718"></a><a name="instance%20HMember%20e1%20(e%20':%20l)%20br%20class%20HMember'%20(b0%20::%20Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20b0%20e1%20l%20-%3e%20b%20instance%20HMember'%20True%20e1%20l%20True%20instance%20(HMember%20e1%20l%20br)%20=%3e%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMember</span> <span class='hs-varid'>e1</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-conid'>False</span>
<a name="line-719"></a><a name="instance%20HMember%20e1%20(e%20':%20l)%20br%20class%20HMember'%20(b0%20::%20Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(b%20::%20Bool)%20%7c%20b0%20e1%20l%20-%3e%20b%20instance%20HMember'%20True%20e1%20l%20True%20instance%20(HMember%20e1%20l%20br)%20=%3e%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>HMember'</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HMember</span>  <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>br</span>
<a name="line-720"></a><a name="HMember'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HMember'</span> <span class='hs-layout'>(</span><span class='hs-varid'>b0</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b0</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-721"></a><a name="instance%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMember'</span> <span class='hs-conid'>True</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-conid'>True</span>
<a name="line-722"></a><a name="instance%20HMember'%20False%20e1%20l%20br%20--%20The%20following%20is%20a%20similar%20type-only%20membership%20test%20--%20It%20uses%20the%20user-supplied%20curried%20type%20equality%20predicate%20pred%20type%20family%20HMemberP%20pred%20e1%20(l%20::%20%5b*%5d)%20::%20Bool%20type%20instance%20HMemberP%20pred%20e1%20'%5b%5d%20=%20False%20--type%20instance%20HMemberP%20pred%20e1%20(e%20':%20l)%20=%20HMemberP'%20pred%20e1%20l%20(ApplyR%20pred%20(e1,e))%20type%20family%20HMemberP'%20pred%20e1%20(l%20::%20%5b*%5d)%20pb%20::%20Bool%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20True)%20=%20True%20type%20instance%20HMemberP'%20pred%20e1%20l%20(Proxy%20False)%20=%20HMemberP%20pred%20e1%20l%20hMember%20::%20HMember%20e%20l%20b%20=%3e%20Proxy%20e%20-%3e%20Proxy%20l%20-%3e%20Proxy%20b%20hMember%20=%20undefined%20--%20**%20Another%20type-level%20membership%20test%20--%20--%20%7c%20Check%20to%20see%20if%20an%20element%20e%20occurs%20in%20a%20list%20l%20--%20If%20not,%20return%20'Nothing%20--%20If%20the%20element%20does%20occur,%20return%20'Just%20l1%20--%20where%20l1%20is%20a%20type-level%20list%20without%20e%20class%20HMemberM%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r%20::%20Maybe%20%5bk%5d)%20%7c%20e1%20l%20-%3e%20r%20instance%20HMemberM%20e1%20'%5b%5d%20'Nothing%20instance%20(HEq%20e1%20e%20b,%20HMemberM1%20b%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMember</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HMember'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-varid'>br</span>
<a name="line-723"></a>
<a name="line-724"></a><span class='hs-comment'>-- The following is a similar type-only membership test</span>
<a name="line-725"></a><span class='hs-comment'>-- It uses the user-supplied curried type equality predicate pred</span>
<a name="line-726"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HMemberP</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-727"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberP</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>e1</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-728"></a><span class='hs-comment'>--type instance HMemberP pred e1 (e ': l) = HMemberP' pred e1 l (ApplyR pred (e1,e))</span>
<a name="line-729"></a>
<a name="line-730"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>family</span> <span class='hs-conid'>HMemberP'</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>pb</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-731"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberP'</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-732"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberP'</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HMemberP</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span>
<a name="line-733"></a> 
<a name="line-734"></a>
<a name="line-735"></a><a name="hMember"></a><span class='hs-definition'>hMember</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HMember</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>b</span>
<a name="line-736"></a><span class='hs-definition'>hMember</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<a name="line-737"></a>
<a name="line-738"></a><a name="HMemberM"></a><span class='hs-comment'>-- ** Another type-level membership test</span>
<a name="line-739"></a><a name="HMemberM"></a><span class='hs-comment'>--</span>
<a name="line-740"></a><a name="HMemberM"></a><span class='hs-comment'>-- | Check to see if an element e occurs in a list l</span>
<a name="line-741"></a><a name="HMemberM"></a><span class='hs-comment'>-- If not, return 'Nothing</span>
<a name="line-742"></a><a name="HMemberM"></a><span class='hs-comment'>-- If the element does occur, return 'Just l1</span>
<a name="line-743"></a><a name="HMemberM"></a><span class='hs-comment'>-- where l1 is a type-level list without e</span>
<a name="line-744"></a><a name="HMemberM"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HMemberM</span> <span class='hs-layout'>(</span><span class='hs-varid'>e1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-745"></a><a name="instance%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberM</span> <span class='hs-varid'>e1</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-chr'>'</span><span class='hs-conid'>Nothing</span>
<a name="line-746"></a><a name="instance%20HMemberM%20e1%20(e%20':%20l)%20res%20class%20HMemberM1%20(b::Bool)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM1%20True%20e1%20(e%20':%20l)%20('Just%20l)%20instance%20(HMemberM%20e1%20l%20r,%20HMemberM2%20r%20e1%20(e%20':%20l)%20res)%20=%3e%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>HMemberM1</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-747"></a>      <span class='hs-keyglyph'>=&gt;</span>  <span class='hs-conid'>HMemberM</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>res</span>
<a name="line-748"></a>
<a name="line-749"></a><a name="HMemberM1"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HMemberM1</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-750"></a><a name="instance%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberM1</span> <span class='hs-conid'>True</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-chr'>'</span><span class='hs-conid'>Just</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-751"></a><a name="instance%20HMemberM1%20False%20e1%20(e%20':%20l)%20res%20class%20HMemberM2%20(b::Maybe%20%5bk%5d)%20(e1%20::%20k)%20(l%20::%20%5bk%5d)%20(r::Maybe%20%5bk%5d)%20%7c%20b%20e1%20l%20-%3e%20r%20instance%20HMemberM2%20Nothing%20e1%20l%20Nothing%20instance%20HMemberM2%20(Just%20l1)%20e1%20(e%20':%20l)%20(Just%20(e%20':%20l1))%20--%20--------------------------------------------------------------------------%20--%20*%20Staged%20equality%20for%20lists%20--%20$note%20removed.%20use%20Typeable%20instead%20%7b-%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20True%20instance%20HStagedEq%20(HList%20'%5b%5d)%20(HList%20(e%20':%20l))%20where%20hStagedEq%20_%20_%20=%20False%20instance%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20'%5b%5d)%20where%20hStagedEq%20_%20_%20=%20False%20instance%20(%20HEq%20e%20e'%20b%20,%20HStagedEq%20(HList%20l)%20(HList%20l')%20,%20HStagedEq'%20b%20e%20e'%20)%20=%3e%20HStagedEq%20(HList%20(e%20':%20l))%20(HList%20(e'%20':%20l'))%20where%20hStagedEq%20(HCons%20e%20l)%20(HCons%20e'%20l')%20=%20(hStagedEq'%20b%20e%20e')%20&&%20b'%20where%20b%20=%20proxy%20::%20Proxy%20b%20b'%20=%20hStagedEq%20l%20l'%20class%20HStagedEq'%20(b%20::%20Bool)%20e%20e'%20where%20hStagedEq'%20::%20Proxy%20b%20-%3e%20e%20-%3e%20e'%20-%3e%20Bool%20instance%20HStagedEq'%20False%20e%20e'%20where%20hStagedEq'%20_%20_%20_%20=%20False%20instance%20Eq%20e%20=%3e%20HStagedEq'%20True%20e%20e%20where%20hStagedEq'%20_%20=%20(==)%20-%7d%20%7b-%20--%20*%20Static%20set%20property%20based%20on%20HEq%20class%20HSet%20l%20instance%20HSet%20HNil%20instance%20(HMember%20e%20l%20HFalse,%20HSet%20l)%20=%3e%20HSet%20(HCons%20e%20l)%20-%7d%20--%20*%20Find%20an%20element%20in%20a%20set%20based%20on%20HEq%20--%20%7c%20It%20is%20a%20pure%20type-level%20operation%20class%20HFind%20(e%20::%20k)%20(l%20::%20%5bk%5d)%20(n%20::%20HNat)%20%7c%20e%20l%20-%3e%20n%20instance%20(HEq%20e1%20e2%20b,%20HFind'%20b%20e1%20l%20n)%20=%3e%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMemberM</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-conid'>HMemberM2</span> <span class='hs-varid'>r</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-752"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HMemberM1</span> <span class='hs-conid'>False</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>res</span>
<a name="line-753"></a>
<a name="line-754"></a><a name="HFind"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HMemberM2</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-755"></a><a name="instance%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberM2</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-conid'>Nothing</span>
<a name="line-756"></a><a name="instance%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HMemberM2</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-757"></a>
<a name="line-758"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-759"></a>
<a name="line-760"></a><span class='hs-comment'>-- * Staged equality for lists</span>
<a name="line-761"></a><span class='hs-comment'>-- $note removed. use Typeable instead</span>
<a name="line-762"></a>
<a name="line-763"></a><span class='hs-comment'>{-
<a name="line-764"></a>instance HStagedEq (HList '[]) (HList '[])
<a name="line-765"></a> where
<a name="line-766"></a>  hStagedEq _ _ = True
<a name="line-767"></a>
<a name="line-768"></a>instance HStagedEq (HList '[]) (HList (e ': l))
<a name="line-769"></a> where
<a name="line-770"></a>  hStagedEq _ _ = False
<a name="line-771"></a>
<a name="line-772"></a>instance HStagedEq (HList (e ': l)) (HList '[])
<a name="line-773"></a> where
<a name="line-774"></a>  hStagedEq _ _ = False
<a name="line-775"></a>
<a name="line-776"></a>instance ( HEq e e' b
<a name="line-777"></a>         , HStagedEq (HList l) (HList l')
<a name="line-778"></a>         , HStagedEq' b e e'
<a name="line-779"></a>         )
<a name="line-780"></a>      =&gt;   HStagedEq (HList (e ': l)) (HList (e' ': l'))
<a name="line-781"></a> where
<a name="line-782"></a>  hStagedEq (HCons e l) (HCons e' l') = (hStagedEq' b e e') &amp;&amp; b'
<a name="line-783"></a>   where
<a name="line-784"></a>    b  = proxy :: Proxy b
<a name="line-785"></a>    b' = hStagedEq l l'
<a name="line-786"></a>
<a name="line-787"></a>class HStagedEq' (b :: Bool) e e'
<a name="line-788"></a> where
<a name="line-789"></a>  hStagedEq' :: Proxy b -&gt; e -&gt; e' -&gt; Bool
<a name="line-790"></a>
<a name="line-791"></a>instance HStagedEq' False e e'
<a name="line-792"></a> where
<a name="line-793"></a>  hStagedEq' _ _ _ = False
<a name="line-794"></a>
<a name="line-795"></a>instance Eq e =&gt; HStagedEq' True e e
<a name="line-796"></a> where
<a name="line-797"></a>  hStagedEq' _ = (==)
<a name="line-798"></a>-}</span>
<a name="line-799"></a>
<a name="line-800"></a><span class='hs-comment'>{-
<a name="line-801"></a>
<a name="line-802"></a>
<a name="line-803"></a>
<a name="line-804"></a>-- * Static set property based on HEq
<a name="line-805"></a>class HSet l
<a name="line-806"></a>instance HSet HNil
<a name="line-807"></a>instance (HMember e l HFalse, HSet l) =&gt; HSet (HCons e l)
<a name="line-808"></a>-}</span>
<a name="line-809"></a>
<a name="line-810"></a><a name="HFind"></a><span class='hs-comment'>-- * Find an element in a set based on HEq</span>
<a name="line-811"></a><a name="HFind"></a><span class='hs-comment'>-- | It is a pure type-level operation</span>
<a name="line-812"></a><a name="HFind"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HFind</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HNat</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n</span>
<a name="line-813"></a>
<a name="line-814"></a><a name="instance%20HFind%20e1%20(e2%20':%20l)%20n%20class%20HFind'%20(b::Bool)%20(e%20::%20k)%20(l::%5bk%5d)%20(n::HNat)%20%7c%20b%20e%20l%20-%3e%20n%20instance%20HFind'%20True%20e%20l%20HZero%20instance%20HFind%20e%20l%20n%20=%3e%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>HFind'</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>l</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFind</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-varid'>e2</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span>
<a name="line-815"></a>
<a name="line-816"></a><a name="HFind'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HFind'</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-keyglyph'>::</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>HNat</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n</span>
<a name="line-817"></a><a name="instance%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HFind'</span> <span class='hs-conid'>True</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-conid'>HZero</span>
<a name="line-818"></a><a name="instance%20HFind'%20False%20e%20l%20(HSucc%20n)%20--%20**%20Membership%20test%20based%20on%20type%20equality%20--%20%7c%20could%20be%20an%20associated%20type%20if%20HEq%20had%20one%20class%20HTMember%20e%20(l%20::%20%5b*%5d)%20(b%20::%20Bool)%20%7c%20e%20l%20-%3e%20b%20instance%20HTMember%20e%20'%5b%5d%20False%20instance%20(HEq%20e%20e'%20b,%20HTMember%20e%20l%20b',%20HOr%20b%20b'%20~%20b'')%20=%3e%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HFind</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HFind'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>HSucc</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-819"></a>
<a name="line-820"></a>
<a name="line-821"></a>
<a name="line-822"></a><span class='hs-comment'>-- ** Membership test based on type equality</span>
<a name="line-823"></a>
<a name="line-824"></a><a name="HTMember"></a><span class='hs-comment'>-- | could be an associated type if HEq had one</span>
<a name="line-825"></a><a name="HTMember"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HTMember</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-826"></a><a name="instance%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HTMember</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-conid'>False</span>
<a name="line-827"></a><a name="instance%20HTMember%20e%20(e'%20':%20l)%20b''%20hTMember%20::%20HTMember%20e%20l%20b%20=%3e%20e%20-%3e%20HList%20l%20-%3e%20Proxy%20b%20hTMember%20_%20_%20=%20Proxy%20--%20*%20Intersection%20based%20on%20HTMember%20class%20HTIntersect%20l1%20l2%20l3%20%7c%20l1%20l2%20-%3e%20l3"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>HTMember</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-conid'>HOr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>b'</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>b''</span><span class='hs-layout'>)</span>
<a name="line-828"></a>      <span class='hs-keyglyph'>=&gt;</span>  <span class='hs-conid'>HTMember</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>b''</span>
<a name="line-829"></a>
<a name="line-830"></a><a name="hTMember"></a><span class='hs-definition'>hTMember</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HTMember</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>b</span>
<a name="line-831"></a><span class='hs-definition'>hTMember</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Proxy</span>
<a name="line-832"></a>
<a name="line-833"></a>
<a name="line-834"></a><span class='hs-comment'>-- * Intersection based on HTMember</span>
<a name="line-835"></a>
<a name="line-836"></a><a name="HTIntersect"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HTIntersect</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>l3</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>l3</span>
<a name="line-837"></a> <span class='hs-keyword'>where</span>
<a name="line-838"></a>  <span class='hs-comment'>-- | Like 'Data.List.intersect'</span>
<a name="line-839"></a>  <span class='hs-varid'>hTIntersect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l3</span>
<a name="line-840"></a>
<a name="line-841"></a><a name="instance%20HTIntersect%20'%5b%5d%20l%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HTIntersect</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>l</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-842"></a> <span class='hs-keyword'>where</span>
<a name="line-843"></a>  <span class='hs-varid'>hTIntersect</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-844"></a>
<a name="line-845"></a><a name="instance%20HTIntersect%20(h%20':%20t)%20l1%20l2"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span> <span class='hs-conid'>HTMember</span> <span class='hs-varid'>h</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>b</span>
<a name="line-846"></a>         <span class='hs-layout'>,</span> <span class='hs-conid'>HTIntersectBool</span> <span class='hs-varid'>b</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-847"></a>         <span class='hs-layout'>)</span>
<a name="line-848"></a>         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HTIntersect</span> <span class='hs-layout'>(</span><span class='hs-varid'>h</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-849"></a> <span class='hs-keyword'>where</span>
<a name="line-850"></a>  <span class='hs-varid'>hTIntersect</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hTIntersectBool</span> <span class='hs-varid'>b</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span>
<a name="line-851"></a>   <span class='hs-keyword'>where</span>
<a name="line-852"></a>    <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hTMember</span> <span class='hs-varid'>h</span> <span class='hs-varid'>l1</span>
<a name="line-853"></a>
<a name="line-854"></a><a name="HTIntersectBool"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HTIntersectBool</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>l2</span>
<a name="line-855"></a> <span class='hs-keyword'>where</span>
<a name="line-856"></a> <span class='hs-varid'>hTIntersectBool</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>h</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l2</span>
<a name="line-857"></a>
<a name="line-858"></a><a name="instance%20HTIntersectBool%20True%20h%20t%20l1%20(h%20':%20l2)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HTIntersect</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-859"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HTIntersectBool</span> <span class='hs-conid'>True</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-layout'>(</span><span class='hs-varid'>h</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span>
<a name="line-860"></a> <span class='hs-keyword'>where</span>
<a name="line-861"></a>  <span class='hs-varid'>hTIntersectBool</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>h</span> <span class='hs-layout'>(</span><span class='hs-varid'>hTIntersect</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span>
<a name="line-862"></a>
<a name="line-863"></a><a name="instance%20HTIntersectBool%20False%20h%20t%20l1%20l2"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HTIntersect</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-864"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HTIntersectBool</span> <span class='hs-conid'>False</span> <span class='hs-varid'>h</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-865"></a> <span class='hs-keyword'>where</span>
<a name="line-866"></a>  <span class='hs-varid'>hTIntersectBool</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hTIntersect</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l1</span>
<a name="line-867"></a>
<a name="line-868"></a>
<a name="line-869"></a><span class='hs-comment'>-- * Turn a heterogeneous list into a homogeneous one</span>
<a name="line-870"></a>
<a name="line-871"></a><a name="HList2List"></a><span class='hs-comment'>-- | Same as @hMapOut Id@</span>
<a name="line-872"></a><a name="HList2List"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HList2List</span> <span class='hs-varid'>l</span> <span class='hs-varid'>e</span>
<a name="line-873"></a> <span class='hs-keyword'>where</span>
<a name="line-874"></a>  <span class='hs-varid'>hList2List</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span>
<a name="line-875"></a>
<a name="line-876"></a><a name="instance%20HList2List%20'%5b%5d%20e"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HList2List</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>e</span>
<a name="line-877"></a> <span class='hs-keyword'>where</span>
<a name="line-878"></a>  <span class='hs-varid'>hList2List</span> <span class='hs-conid'>HNil</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-879"></a>
<a name="line-880"></a><a name="instance%20HList2List%20(e%20':%20l)%20e"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HList2List</span> <span class='hs-varid'>l</span> <span class='hs-varid'>e</span>
<a name="line-881"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HList2List</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-882"></a> <span class='hs-keyword'>where</span>
<a name="line-883"></a>  <span class='hs-varid'>hList2List</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span><span class='hs-conop'>:</span><span class='hs-varid'>hList2List</span> <span class='hs-varid'>l</span>
<a name="line-884"></a>
<a name="line-885"></a>
<a name="line-886"></a>
<a name="line-887"></a>
<a name="line-888"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-889"></a><span class='hs-comment'>-- * With 'HMaybe'</span>
<a name="line-890"></a>
<a name="line-891"></a><span class='hs-comment'>-- ** Turn list in a list of justs</span>
<a name="line-892"></a><span class='hs-comment'>-- | the same as @map Just@</span>
<a name="line-893"></a><span class='hs-comment'>--</span>
<a name="line-894"></a><span class='hs-comment'>-- &gt;&gt;&gt; toHJust (2 .*. 'a' .*. HNil)</span>
<a name="line-895"></a><span class='hs-comment'>-- H[HJust 2, HJust 'a']</span>
<a name="line-896"></a><span class='hs-comment'>--</span>
<a name="line-897"></a><span class='hs-comment'>-- &gt;&gt;&gt; toHJust2 (2 .*. 'a' .*. HNil)</span>
<a name="line-898"></a><span class='hs-comment'>-- H[HJust 2, HJust 'a']</span>
<a name="line-899"></a>
<a name="line-900"></a><a name="ToHJust"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>ToHJust</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>l'</span><span class='hs-layout'>,</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>l</span>
<a name="line-901"></a> <span class='hs-keyword'>where</span>
<a name="line-902"></a>  <span class='hs-varid'>toHJust</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l'</span>
<a name="line-903"></a>
<a name="line-904"></a><a name="instance%20ToHJust%20'%5b%5d%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>ToHJust</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-905"></a> <span class='hs-keyword'>where</span>
<a name="line-906"></a>  <span class='hs-varid'>toHJust</span> <span class='hs-conid'>HNil</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-907"></a>
<a name="line-908"></a><a name="instance%20ToHJust%20(e%20':%20l)%20(HJust%20e%20':%20l')"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>ToHJust</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ToHJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span>
<a name="line-909"></a> <span class='hs-keyword'>where</span>
<a name="line-910"></a>  <span class='hs-varid'>toHJust</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>toHJust</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-911"></a>
<a name="line-912"></a><a name="toHJust2"></a><span class='hs-comment'>-- | alternative implementation. The Apply instance is in "Data.HList.FakePrelude".</span>
<a name="line-913"></a><span class='hs-comment'>-- A longer type could be inferred.</span>
<a name="line-914"></a><span class='hs-comment'>-- toHJust2 :: (HMap' (HJust ()) a b) =&gt; HList a -&gt; HList b</span>
<a name="line-915"></a><span class='hs-definition'>toHJust2</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-916"></a>
<a name="line-917"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-918"></a><span class='hs-comment'>-- ** Extract justs from list of maybes</span>
<a name="line-919"></a><span class='hs-comment'>--</span>
<a name="line-920"></a><span class='hs-comment'>-- &gt;&gt;&gt; let xs = 2 .*. 'a' .*. HNil</span>
<a name="line-921"></a><span class='hs-comment'>-- &gt;&gt;&gt; fromHJust (toHJust xs) == xs</span>
<a name="line-922"></a><span class='hs-comment'>-- True</span>
<a name="line-923"></a>
<a name="line-924"></a><a name="FromHJust"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>FromHJust</span> <span class='hs-varid'>l</span>
<a name="line-925"></a> <span class='hs-keyword'>where</span>
<a name="line-926"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>FromHJustR</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-927"></a>  <span class='hs-varid'>fromHJust</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>FromHJustR</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-928"></a>
<a name="line-929"></a><a name="instance%20FromHJust%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>FromHJust</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-930"></a> <span class='hs-keyword'>where</span>
<a name="line-931"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>FromHJustR</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-932"></a>  <span class='hs-varid'>fromHJust</span> <span class='hs-conid'>HNil</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HNil</span>
<a name="line-933"></a>
<a name="line-934"></a><a name="instance%20FromHJust%20(HNothing%20':%20l)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>FromHJust</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FromHJust</span> <span class='hs-layout'>(</span><span class='hs-conid'>HNothing</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-935"></a> <span class='hs-keyword'>where</span>
<a name="line-936"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>FromHJustR</span> <span class='hs-layout'>(</span><span class='hs-conid'>HNothing</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FromHJustR</span> <span class='hs-varid'>l</span>
<a name="line-937"></a>  <span class='hs-varid'>fromHJust</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromHJust</span> <span class='hs-varid'>l</span>
<a name="line-938"></a>
<a name="line-939"></a><a name="instance%20FromHJust%20(HJust%20e%20':%20l)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>FromHJust</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FromHJust</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-940"></a> <span class='hs-keyword'>where</span>
<a name="line-941"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>FromHJustR</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>FromHJustR</span> <span class='hs-varid'>l</span>
<a name="line-942"></a>  <span class='hs-varid'>fromHJust</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromHJust</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-943"></a>
<a name="line-944"></a><span class='hs-comment'>-- *** alternative implementation</span>
<a name="line-945"></a>
<a name="line-946"></a><a name="fromHJust2"></a><span class='hs-comment'>-- | A longer type could be inferred.</span>
<a name="line-947"></a><span class='hs-comment'>-- fromHJust2 :: (HMap' HFromJust a b) =&gt; HList a -&gt; HList b</span>
<a name="line-948"></a><span class='hs-definition'>fromHJust2</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hMap</span> <span class='hs-conid'>HFromJust</span> <span class='hs-varid'>xs</span>
<a name="line-949"></a>
<a name="line-950"></a><a name="HFromJust"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HFromJust</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HFromJust</span>
<a name="line-951"></a><a name="instance%20ApplyAB%20HFromJust%20hJustA%20a"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>hJustA</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HJust</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-conid'>HFromJust</span> <span class='hs-varid'>hJustA</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-952"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HJust</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-953"></a>
<a name="line-954"></a>
<a name="line-955"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-956"></a><span class='hs-comment'>-- * Annotated lists</span>
<a name="line-957"></a>
<a name="line-958"></a><a name="HAddTag"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HAddTag</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HAddTag</span> <span class='hs-varid'>t</span>
<a name="line-959"></a><a name="HRmTag"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HRmTag</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HRmTag</span>
<a name="line-960"></a>
<a name="line-961"></a><a name="hAddTag"></a><span class='hs-comment'>-- hAddTag :: HMap' (HAddTag t) l r =&gt; t -&gt; HList l -&gt; HList r</span>
<a name="line-962"></a><span class='hs-definition'>hAddTag</span> <span class='hs-varid'>t</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>HAddTag</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
<a name="line-963"></a>
<a name="line-964"></a><a name="hRmTag"></a><span class='hs-comment'>-- hRmTag ::  HMap HRmTag l =&gt; HList l -&gt; HList (HMapR HRmTag l)</span>
<a name="line-965"></a><span class='hs-definition'>hRmTag</span> <span class='hs-varid'>l</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hMap</span> <span class='hs-conid'>HRmTag</span> <span class='hs-varid'>l</span>
<a name="line-966"></a>
<a name="line-967"></a><a name="instance%20ApplyAB%20(HAddTag%20t)%20e%20et"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>et</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>HAddTag</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-varid'>et</span>
<a name="line-968"></a> <span class='hs-keyword'>where</span>
<a name="line-969"></a>  <span class='hs-varid'>applyAB</span> <span class='hs-layout'>(</span><span class='hs-conid'>HAddTag</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-970"></a>
<a name="line-971"></a>
<a name="line-972"></a><a name="instance%20ApplyAB%20HRmTag%20(e,t)%20e'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ApplyAB</span> <span class='hs-conid'>HRmTag</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>e'</span>
<a name="line-973"></a> <span class='hs-keyword'>where</span>
<a name="line-974"></a>  <span class='hs-varid'>applyAB</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span>
<a name="line-975"></a>
<a name="line-976"></a>
<a name="line-977"></a><a name="hFlag"></a><span class='hs-comment'>-- | Annotate list with a type-level Boolean</span>
<a name="line-978"></a><span class='hs-comment'>-- hFlag :: HMap' (HAddTag (Proxy True)) l r =&gt; HList l -&gt; HList r</span>
<a name="line-979"></a><span class='hs-definition'>hFlag</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hAddTag</span> <span class='hs-varid'>hTrue</span> <span class='hs-varid'>l</span>
<a name="line-980"></a>
<a name="line-981"></a>
<a name="line-982"></a><span class='hs-comment'>-- --------------------------------------------------------------------------</span>
<a name="line-983"></a><span class='hs-comment'>-- * Splitting by HTrue and HFalse</span>
<a name="line-984"></a>
<a name="line-985"></a><span class='hs-comment'>-- | Analogus to Data.List.'Data.List.partition' 'snd'</span>
<a name="line-986"></a><span class='hs-comment'>--</span>
<a name="line-987"></a><span class='hs-comment'>-- &gt;&gt;&gt; hSplit $ (2,hTrue) .*. (3,hTrue) .*. (1,hFalse) .*. HNil</span>
<a name="line-988"></a><span class='hs-comment'>-- (H[2, 3],H[1])</span>
<a name="line-989"></a><span class='hs-comment'>--</span>
<a name="line-990"></a><span class='hs-comment'>-- it might make more sense to instead have @LVPair Bool e@</span>
<a name="line-991"></a><span class='hs-comment'>-- instead of @(e, Proxy Bool)@ since the former has the same</span>
<a name="line-992"></a><span class='hs-comment'>-- runtime representation as @e@</span>
<a name="line-993"></a>
<a name="line-994"></a><a name="HSplit"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HSplit</span> <span class='hs-varid'>l</span>
<a name="line-995"></a> <span class='hs-keyword'>where</span>
<a name="line-996"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitT</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-997"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitF</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span>
<a name="line-998"></a>  <span class='hs-varid'>hSplit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HSplitT</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HSplitF</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-999"></a>
<a name="line-1000"></a><a name="instance%20HSplit%20'%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HSplit</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-1001"></a> <span class='hs-keyword'>where</span>
<a name="line-1002"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitT</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-1003"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitF</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-1004"></a>  <span class='hs-varid'>hSplit</span> <span class='hs-conid'>HNil</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>HNil</span><span class='hs-layout'>,</span><span class='hs-conid'>HNil</span><span class='hs-layout'>)</span>
<a name="line-1005"></a>
<a name="line-1006"></a><a name="instance%20HSplit%20((e,%20Proxy%20True)%20':%20l)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HSplit</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HSplit</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-conid'>Proxy</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-1007"></a> <span class='hs-keyword'>where</span>
<a name="line-1008"></a>
<a name="line-1009"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitT</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>HSplitT</span> <span class='hs-varid'>l</span>
<a name="line-1010"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitF</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HSplitF</span> <span class='hs-varid'>l</span>
<a name="line-1011"></a>
<a name="line-1012"></a>  <span class='hs-varid'>hSplit</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l'</span><span class='hs-layout'>,</span><span class='hs-varid'>l''</span><span class='hs-layout'>)</span>
<a name="line-1013"></a>   <span class='hs-keyword'>where</span>
<a name="line-1014"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span><span class='hs-varid'>l''</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hSplit</span> <span class='hs-varid'>l</span>
<a name="line-1015"></a>
<a name="line-1016"></a><a name="instance%20HSplit%20((e,Proxy%20False)%20':%20l)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>HSplit</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HSplit</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-1017"></a> <span class='hs-keyword'>where</span>
<a name="line-1018"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitT</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HSplitT</span> <span class='hs-varid'>l</span>
<a name="line-1019"></a>  <span class='hs-keyword'>type</span> <span class='hs-conid'>HSplitF</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-conid'>Proxy</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-conid'>HSplitF</span> <span class='hs-varid'>l</span>
<a name="line-1020"></a>
<a name="line-1021"></a>  <span class='hs-varid'>hSplit</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l''</span><span class='hs-layout'>)</span>
<a name="line-1022"></a>   <span class='hs-keyword'>where</span>
<a name="line-1023"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span><span class='hs-varid'>l''</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hSplit</span> <span class='hs-varid'>l</span>
<a name="line-1024"></a>
<a name="line-1025"></a><span class='hs-comment'>{-
<a name="line-1026"></a>
<a name="line-1027"></a>Let expansion makes a difference to Hugs:
<a name="line-1028"></a>
<a name="line-1029"></a>HListPrelude&gt; let x = (hFlag (HCons "1" HNil)) in hSplit x
<a name="line-1030"></a>(HCons "1" HNil,HNil)
<a name="line-1031"></a>HListPrelude&gt; hSplit (hFlag (HCons "1" HNil))
<a name="line-1032"></a>ERROR - Unresolved overloading
<a name="line-1033"></a>*** Type       : HSplit (HCons ([Char],HTrue) HNil) a b =&gt; (a,b)
<a name="line-1034"></a>*** Expression : hSplit (hFlag (HCons "1" HNil))
<a name="line-1035"></a>
<a name="line-1036"></a>
<a name="line-1037"></a>-}</span>
</pre></body>
</html>
