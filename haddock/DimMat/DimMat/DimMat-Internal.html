<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>DimMat.Internal</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_DimMat-Internal.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/DimMat-Internal.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">DimMat-0.1.0.0: matrices with compile-time checked units and sizes</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">DimMat.Internal</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Replacements for Dimensional classes</a></li><li><a href="#g:2">AD</a></li><li><a href="#g:3">GADT for linear algebra with units</a><ul><li><a href="#g:4">pretty instance</a></li></ul></li><li><a href="#g:5">Constraints</a><ul><li><a href="#g:6">Zip</a></li></ul></li><li><a href="#g:7">DimMatFromTuple</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>an incomplete extension of dimensional-tf to work with hmatrix and ad
Haddocks are organized to follow hmatrix</p><p>note: for subscripting, use the <code><a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a></code> while the units still use <code><a href="N.html#t:NumType">NumType</a></code></p><p>TODO:</p><ul><li>Friendly syntax for introduction (more matD)</li><li>Friendly syntax for elimination (matD as pattern)</li><li>A pretty-printer that multiplies out the dimensions at each place?
   The current show instance makes you mentally multiply out row and column units
   (which helps you to see the big picture, but may be more work in other cases)</li><li>check that all types that could could be inferred are</li><li>default columns/rows to dimensionless?</li><li>missing operations (check export list comments)</li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="../dimensional/Numeric-Units-Dimensional.html#t:Mul">Mul</a> a b c =&gt; <a href="#t:Mul">Mul</a> a b c</li><li class="src short"><span class="keyword">class</span> <a href="../dimensional/Numeric-Units-Dimensional.html#t:Div">Div</a> a b c =&gt; <a href="#t:Div">Div</a> a b c</li><li class="src short"><span class="keyword">data</span> <a href="#t:D">D</a> sh e <span class="keyword">where</span><ul class="subs"><li><a href="#v:DMat">DMat</a> :: (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:Container">Container</a> <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> e, <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e) =&gt; <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` e</li><li><a href="#v:DVec">DVec</a> :: (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:Container">Container</a> <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Vector.html#t:Vector">Vector</a> e, <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e) =&gt; <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Vector.html#t:Vector">Vector</a> e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r]`)` e</li><li><a href="#v:DScal">DScal</a> :: <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e =&gt; e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, [])` e</li></ul></li><li class="src short"><a href="#v:pad">pad</a> :: [<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>] -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>]</li><li class="src short"><span class="keyword">class</span> <a href="#t:PPUnits">PPUnits</a> sh <span class="keyword">where</span><ul class="subs"><li><a href="#v:ppUnits">ppUnits</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> sh -&gt; [[<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>]]</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:PPUnits-39-">PPUnits'</a> sh <span class="keyword">where</span><ul class="subs"><li><a href="#v:ppUnits-39-">ppUnits'</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> sh -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>]</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:ShowDimSpec">ShowDimSpec</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:showDimSpec">showDimSpec</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:MultEq">MultEq</a> a b c</li><li class="src short"><span class="keyword">class</span> (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a b, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> b c) =&gt; <a href="#t:Zip3">Zip3</a> op a b c</li><li class="src short"><span class="keyword">class</span> <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a b =&gt; <a href="#t:Zip2">Zip2</a> op a b c</li><li class="src short"><span class="keyword">class</span> <a href="#t:Zip1">Zip1</a> op a b c</li><li class="src short"><span class="keyword">class</span> <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a ab =&gt; <a href="#t:Outer">Outer</a> a b ab</li><li class="src short"><span class="keyword">class</span> <a href="#t:DimMatFromTuple">DimMatFromTuple</a> ijs r1 r c e</li><li class="src short"><span class="keyword">type family</span> <a href="#t:TupleToHListU">TupleToHListU</a> a :: [*]</li><li class="src short"><span class="keyword">type family</span> <a href="#t:TuplesToHListU">TuplesToHListU</a> a :: [[*]]</li><li class="src short"><span class="keyword">type family</span> <a href="#t:DMFromTuple1">DMFromTuple1</a> e b b' :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:DMFromTuple2">DMFromTuple2</a> e b b' :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:DMFromTuple3">DMFromTuple3</a> e b b' :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><a href="#v:toDM">toDM</a> :: <a href="DimMat-Internal.html#t:DimMatFromTuple">DimMatFromTuple</a> ijs r1 r c e =&gt; ijs -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` e)</li><li class="src short"><span class="keyword">type family</span> <a href="#t:InnerCxt">InnerCxt</a> t a b :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">class</span> (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a b, <a href="DimMat-Internal.html#t:InnerCxt">InnerCxt</a> c a b) =&gt; <a href="#t:Inner">Inner</a> a b c</li><li class="src short"><span class="keyword">class</span> <a href="#t:ProdEq">ProdEq</a> a b</li><li class="src short"><span class="keyword">class</span> <a href="#t:RecipEq">RecipEq</a> a aInv</li><li class="src short"><span class="keyword">type family</span> <a href="#t:AtEq2">AtEq2</a> a n b m c :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">type family</span> <a href="#t:AtEq">AtEq</a> a n b :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><a href="#v:-64--62-">(@&gt;)</a> :: (<a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> i, <a href="DimMat-Internal.html#t:AtEq">AtEq</a> r i ri, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> r1 ri u) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r]`)` a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> i -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> u a</li><li class="src short"><a href="#v:-64--64--62-">(@@&gt;)</a> :: (<a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> i, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> j, <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> (r1 : r) i (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : c) j ty) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> j) -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> ty a</li><li class="src short"><a href="#v:pnorm">pnorm</a> :: (<a href="DimMat-Internal.html#t:AllEq">AllEq</a> r1 r, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> c) =&gt; <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:NormType">NormType</a> -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> r1 (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:RealOf">RealOf</a> a)</li><li class="src short"><span class="keyword">class</span> <a href="#t:AllEq">AllEq</a> a xs</li><li class="src short"><span class="keyword">class</span> <a href="#t:Dot">Dot</a> a b c <span class="keyword">where</span><ul class="subs"><li><a href="#v:dot">dot</a> :: <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Element">Element</a> e =&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:Trans">Trans</a> a b <span class="keyword">where</span><ul class="subs"><li><a href="#v:trans">trans</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:PInv">PInv</a> a b <span class="keyword">where</span><ul class="subs"><li><a href="#v:pinv">pinv</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:LengthSndTwo">LengthSndTwo</a> a :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:AreRecips">AreRecips</a> a b = <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a b <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a></li><li class="src short"><a href="#v:inv">inv</a> :: (<a href="DimMat-Internal.html#t:PInv">PInv</a> a b, b ~ `(t1, `[t2, t3]`)`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e</li><li class="src short"><a href="#v:pinvTol">pinvTol</a> :: (<a href="DimMat-Internal.html#t:PInv">PInv</a> a b, b ~ `(t1, `[t2, t3]`)`) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e</li><li class="src short"><span class="keyword">class</span> <a href="#t:Det">Det</a> a b <span class="keyword">where</span><ul class="subs"><li><a href="#v:det">det</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> b e</li></ul></li><li class="src short"><a href="#v:expm">expm</a> :: <a href="DimMat-Internal.html#t:AreRecips">AreRecips</a> r c =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a</li><li class="src short"><span class="keyword">class</span> <a href="#t:Scale">Scale</a> a b c <span class="keyword">where</span><ul class="subs"><li><a href="#v:scale">scale</a> ::  <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e</li></ul></li><li class="src short"><a href="#v:fromQty">fromQty</a> :: <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e =&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e</li><li class="src short"><a href="#v:toQty">toQty</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e</li><li class="src short"><span class="keyword">class</span> <a href="#t:ScaleRecip">ScaleRecip</a> a b c <span class="keyword">where</span><ul class="subs"><li><a href="#v:scaleRecip">scaleRecip</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:ScaleRecip1">ScaleRecip1</a> bool a b c <span class="keyword">where</span><ul class="subs"><li><a href="#v:scaleRecip1">scaleRecip1</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> bool -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:ScaleRecipCxt">ScaleRecipCxt</a> r1 r1' r r' rs rs' a b c = (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> a (r1' : r') (r1 : r), <a href="DimMat-Internal.html#t:MultEq">MultEq</a> rs rs' <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>, b ~ `(r1, r : rs)`, c ~ `(r1', r' : rs')`)</li><li class="src short"><a href="#v:recipMat">recipMat</a> :: <span class="keyword">forall</span> b c e. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="DimMat-Internal.html#t:ScaleRecip">ScaleRecip</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> b c) =&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e</li><li class="src short"><a href="#v:liftH2">liftH2</a> ::  (<span class="keyword">forall</span> h f. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:Container">Container</a> f e, h ~ f e) =&gt; h -&gt; h -&gt; h) -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e</li><li class="src short"><a href="#v:add">add</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e</li><li class="src short"><a href="#v:sub">sub</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e</li><li class="src short"><a href="#v:mulMat">mulMat</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as bs cs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a b c, cs ~ `[t1, t2]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e</li><li class="src short"><a href="#v:mulVec">mulVec</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as bs cs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a b c, cs ~ `[t1]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e</li><li class="src short"><a href="#v:divideMat">divideMat</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as cs bs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a c b, cs ~ `[t1, t2]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e</li><li class="src short"><a href="#v:divideVec">divideVec</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as cs bs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a c b, cs ~ `[t1]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e</li><li class="src short"><a href="#v:arctan2">arctan2</a> :: (bs ~ <a href="DimMat-Internal.html#t:MapMapConst">MapMapConst</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> as) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e</li><li class="src short"><a href="#v:equal">equal</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:CMap">CMap</a> f a b e e' <span class="keyword">where</span><ul class="subs"><li><a href="#v:cmap">cmap</a> :: f -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e'</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:AppendEq-39-">AppendEq'</a> a b ab :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:AppendEq">AppendEq</a> a b ab = (ab ~ <a href="../HList/Data-HList-HListPrelude.html#t:HAppendR">HAppendR</a> a b, <a href="DimMat-Internal.html#t:AppendEq-39-">AppendEq'</a> a b ab, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> a ab) b, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> b ab) a)</li><li class="src short"><span class="keyword">type family</span> <a href="#t:DropPrefix">DropPrefix</a> a ab :: [k]</li><li class="src short"><a href="#v:hconcat">hconcat</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> (rem :: *) a b, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> rem ra rb, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> rem (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : cb) cb', <a href="DimMat-Internal.html#t:AppendEq">AppendEq</a> ca cb' cc) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, ca]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, `[rb, cb]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, cc]`)` e</li><li class="src short"><a href="#v:vconcat">vconcat</a> :: <a href="DimMat-Internal.html#t:AppendEq">AppendEq</a> ra (b : rb) rc =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, ca]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, `[rb, ca]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[rc, ca]`)` e</li><li class="src short"><a href="#v:rank">rank</a> ::  <a href="DimMat-Internal.html#t:D">D</a> t a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:cols">cols</a> ::  <a href="DimMat-Internal.html#t:D">D</a> t a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:rows">rows</a> ::  <a href="DimMat-Internal.html#t:D">D</a> t a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:rowsNT">rowsNT</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, r : c)` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (a : ri))</li><li class="src short"><a href="#v:colsNT">colsNT</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, r : (c : cs))` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : c))</li><li class="src short"><a href="#v:hasRows">hasRows</a> :: (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="../HList/Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n ()) r, <a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> r ~ n) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : ca)` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (n :: <a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a>) -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : ca)` e</li><li class="src short"><a href="#v:hasCols">hasCols</a> :: (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="../HList/Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n ()) ci, <a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> ci ~ n) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : (ca : rest))` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (n :: <a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a>) -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : (ca : rest))` e</li><li class="src short"><span class="keyword">class</span> (<a href="DimMat-Internal.html#t:MapConst">MapConst</a> [] as ~ as) =&gt; <a href="#t:Scalar">Scalar</a> as <span class="keyword">where</span><ul class="subs"><li><a href="#v:scalar">scalar</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e</li></ul></li><li class="src short"><a href="#v:konst">konst</a> :: <span class="keyword">forall</span> e a ra ca. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (a : ra)), <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : ca)), <a href="DimMat-Internal.html#t:AllEq">AllEq</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> ca, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> a ra) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, ca]`)` e</li><li class="src short"><a href="#v:ident">ident</a> :: <span class="keyword">forall</span> ones e. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : ones))) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>, `[ones, ones]`)` e</li><li class="src short"><a href="#v:zeroes">zeroes</a> :: <span class="keyword">forall</span> c a r e. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (a : r)), <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : c))) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[r, c]`)` e</li><li class="src short"><span class="keyword">type family</span> <a href="#t:CanAddConst">CanAddConst</a> a m :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><a href="#v:addConstant">addConstant</a> :: (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="DimMat-Internal.html#t:CanAddConst">CanAddConst</a> a sh) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e</li><li class="src short"><a href="#v:conj">conj</a> ::  <a href="DimMat-Internal.html#t:D">D</a> sh a -&gt; <a href="DimMat-Internal.html#t:D">D</a> sh a</li><li class="src short"><a href="#v:ctrans">ctrans</a> ::  <a href="DimMat-Internal.html#t:D">D</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] x ((:) [*] y ([] [*])))) a -&gt; <a href="DimMat-Internal.html#t:D">D</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] y ((:) [*] x ([] [*])))) a</li><li class="src short"><a href="#v:diag">diag</a> :: (<a href="DimMat-Internal.html#t:MapConst">MapConst</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> r ~ c, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> r c) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[r]`)` t -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[r, c]`)` t</li><li class="src short"><a href="#v:diagBlock">diagBlock</a> :: (<a href="../HList/Data-HList-HList.html#t:HMapOut">HMapOut</a> <a href="DimMat-Internal.html#t:UnDimMat">UnDimMat</a> (b : bs) (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> e), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Num">Num</a> e, <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="DimMat-Internal.html#t:AppendShOf">AppendShOf</a> b bs (<a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e), sh ~ `[r, c]`) =&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> (b : bs) -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e</li><li class="src short"><span class="keyword">data</span> <a href="#t:UnDimMat">UnDimMat</a> = <a href="#v:UnDimMat">UnDimMat</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:DiagBlock">DiagBlock</a> bs t</li><li class="src short"><span class="keyword">class</span> <a href="#t:AppendShOf">AppendShOf</a> a as aas</li><li class="src short"><span class="keyword">type family</span> <a href="#t:AppendDims">AppendDims</a> a b c :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:ToHList">ToHList</a> sh e result <span class="keyword">where</span><ul class="subs"><li><a href="#v:toHList">toHList</a> :: <a href="DimMat-Internal.html#t:D">D</a> sh e -&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> result</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HListFromList">HListFromList</a> e e' <span class="keyword">where</span><ul class="subs"><li><a href="#v:hListFromList">hListFromList</a> :: [e] -&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> e'</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:ToHListRow">ToHListRow</a> a e b :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:AddDimensional">AddDimensional</a> = <a href="#v:AddDimensional">AddDimensional</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:FromHList">FromHList</a> list sh e <span class="keyword">where</span><ul class="subs"><li><a href="#v:fromHList">fromHList</a> :: <a href="../HList/Data-HList-HList.html#t:HList">HList</a> list -&gt; <a href="DimMat-Internal.html#t:D">D</a> sh e</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:RmDimensional">RmDimensional</a> = <a href="#v:RmDimensional">RmDimensional</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:FromHLists">FromHLists</a> lists sh e <span class="keyword">where</span><ul class="subs"><li><a href="#v:fromHLists">fromHLists</a> :: <a href="../HList/Data-HList-HList.html#t:HList">HList</a> lists -&gt; <a href="DimMat-Internal.html#t:D">D</a> sh e</li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:HMapOutWith">HMapOutWith</a> f = <a href="#v:HMapOutWith">HMapOutWith</a> f</li><li class="src short"><span class="keyword">class</span> <a href="#t:ToHListRows-39-">ToHListRows'</a> r c e rows</li><li class="src short"><span class="keyword">data</span> <a href="#t:AddQty">AddQty</a> u</li><li class="src short"><span class="keyword">class</span> <a href="#t:ToHLists">ToHLists</a> sh e xs <span class="keyword">where</span><ul class="subs"><li><a href="#v:toHLists">toHLists</a> :: <a href="DimMat-Internal.html#t:D">D</a> sh e -&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> xs</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:MapMapConst">MapMapConst</a> a xs :: [[k]]</li><li class="src short"><span class="keyword">type family</span> <a href="#t:MapConst">MapConst</a> a xs :: [k]</li><li class="src short"><span class="keyword">type family</span> <a href="#t:FromPairs">FromPairs</a> a :: [*]</li></ul></div><div id="interface"><h1 id="g:1">Replacements for Dimensional classes</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="../dimensional/Numeric-Units-Dimensional.html#t:Mul">Mul</a> a b c =&gt; <a name="t:Mul" class="def">Mul</a> a b c <a href="src/DimMat-Internal.html#Mul" class="link">Source</a></p><div class="doc"><p>a version of Numeric.Units.Dimensional.<code><a href="../dimensional/Numeric-Units-Dimensional.html#t:Mul">Mul</a></code> which
 requires the arguments to include the <code><a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a></code> type constructor</p></div><div class="subs instances"><p id="control.i:Mul" class="caption collapser" onclick="toggleSection('i:Mul')">Instances</p><div id="section.i:Mul" class="show"><table><tr><td class="src">(<a href="../dimensional/Numeric-Units-Dimensional.html#t:Mul">Mul</a> a b c, (~) * a (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l m t i th n j), (~) * b (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l' m' t' i' th' n' j'), (~) * c (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l'' m'' t'' i'' th'' n'' j'')) =&gt; <a href="DimMat-Internal.html#t:Mul">Mul</a> a b c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="../dimensional/Numeric-Units-Dimensional.html#t:Div">Div</a> a b c =&gt; <a name="t:Div" class="def">Div</a> a b c <a href="src/DimMat-Internal.html#Div" class="link">Source</a></p><div class="doc"><p>a version of Numeric.Units.Dimensional.<code><a href="../dimensional/Numeric-Units-Dimensional.html#t:Div">Div</a></code> which
 requires the arguments to include the <code><a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a></code> type constructor</p></div><div class="subs instances"><p id="control.i:Div" class="caption collapser" onclick="toggleSection('i:Div')">Instances</p><div id="section.i:Div" class="show"><table><tr><td class="src">(<a href="../dimensional/Numeric-Units-Dimensional.html#t:Div">Div</a> a b c, (~) * a (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l m t i th n j), (~) * b (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l' m' t' i' th' n' j'), (~) * c (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l'' m'' t'' i'' th'' n'' j'')) =&gt; <a href="DimMat-Internal.html#t:Div">Div</a> a b c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">AD</h1><div class="doc"><p>TODO: gradients, hessians, etc.</p><p>Types for derivative towers can see hlist's <code>HList/Data/HList/broken/Lazy.hs</code>,
but laziness doesn't really make much sense if the <code>take</code> that is eventually used
to get a finite list for printing etc.</p><p>Complications include the fact that AD.grad needs a traversable,
but hmatrix stuff is not traversable (due needing Storable). In ipopt-hs
I got around this problem by copying data. Perhaps that is the solution?</p><pre>BROKEN
grad :: (Num a, AreRecips i iinv, H.Element a, Storable a,
          MapMultEq o iinv r) =&gt;
        (forall s. (AD.Mode s, H.Container H.Vector (AD.AD s a),
                    Storable (AD.AD s a), H.Field (AD.AD s a))
                =&gt; DimMat '[i] (AD.AD s a)
                -&gt; Quantity o (AD.AD s a))
     -&gt; DimMat '[i] a
     -&gt; DimMat '[r] a
grad f (DimVec x) = DimMat (H.fromLists [AD.grad (unQty . f . DimVec . H.fromList) (H.toList x)])
    where unQty (Dimensional a) = a</pre></div><h1 id="g:3">GADT for linear algebra with units</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:D" class="def">D</a> sh e <span class="keyword">where</span> <a href="src/DimMat-Internal.html#D" class="link">Source</a></p><div class="doc"><p>Generalization of <code><a href="../dimensional/Numeric-Units-Dimensional.html#t:Dimensional">Dimensional</a></code> to matrices and vectors. Units
in each coordinate are known at compile-time. This wraps up HMatrix.</p><dl><dt><code> <code><a href="DimMat-Internal.html#v:DMat">DMat</a></code> </code></dt><dd>the units at coordinate ij are <code>(r1 ': r)_i (DOne ': c)_j</code></dd><dt><code> <code><a href="DimMat-Internal.html#v:DVec">DVec</a></code> </code></dt><dd>the units at coordinate i are <code>(r1 ': r)_i</code></dd><dt><code> DScal </code></dt><dd>is the same as Dimensional</dd></dl></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DMat" class="def">DMat</a> :: (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:Container">Container</a> <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> e, <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e) =&gt; <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` e</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DVec" class="def">DVec</a> :: (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:Container">Container</a> <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Vector.html#t:Vector">Vector</a> e, <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e) =&gt; <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Vector.html#t:Vector">Vector</a> e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r]`)` e</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DScal" class="def">DScal</a> :: <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e =&gt; e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, [])` e</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:D" class="caption collapser" onclick="toggleSection('i:D')">Instances</p><div id="section.i:D" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/ansi-wl-pprint/0.6.7.1/doc/html/Text-PrettyPrint-ANSI-Leijen.html#t:Pretty">Pretty</a> (<a href="DimMat-Internal.html#t:D">D</a> sh a) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="DimMat-Internal.html#t:D">D</a> sh a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> a, <a href="DimMat-Internal.html#t:PPUnits">PPUnits</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) sh) =&gt; <a href="http://hackage.haskell.org/packages/archive/ansi-wl-pprint/0.6.7.1/doc/html/Text-PrettyPrint-ANSI-Leijen.html#t:Pretty">Pretty</a> (<a href="DimMat-Internal.html#t:D">D</a> sh a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:4">pretty instance</h2><div class="top"><p class="src"><a name="v:pad" class="def">pad</a> :: [<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>] -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>] <a href="src/DimMat-Internal.html#pad" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:PPUnits" class="def">PPUnits</a> sh <span class="keyword">where</span> <a href="src/DimMat-Internal.html#PPUnits" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:ppUnits" class="def">ppUnits</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> sh -&gt; [[<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>]] <a href="src/DimMat-Internal.html#ppUnits" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:PPUnits" class="caption collapser" onclick="toggleSection('i:PPUnits')">Instances</p><div id="section.i:PPUnits" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:PPUnits">PPUnits</a> [k] ([] k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> x, <a href="DimMat-Internal.html#t:PPUnits">PPUnits</a> [[*]] xs) =&gt; <a href="DimMat-Internal.html#t:PPUnits">PPUnits</a> [[*]] ((:) [*] x xs)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:PPUnits">PPUnits</a> [[*]] ((:) [*] ((:) * r1 r) ((:) [*] c ([] [*]))), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> r1 <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a>), <a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> c, <a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> r, (~) * r1 (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l m t i th n j)) =&gt; <a href="DimMat-Internal.html#t:PPUnits">PPUnits</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] r ((:) [*] c ([] [*]))))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:PPUnits-39-" class="def">PPUnits'</a> sh <span class="keyword">where</span> <a href="src/DimMat-Internal.html#PPUnits%27" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:ppUnits-39-" class="def">ppUnits'</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> sh -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>] <a href="src/DimMat-Internal.html#ppUnits%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:PPUnits-39-" class="caption collapser" onclick="toggleSection('i:PPUnits-39-')">Instances</p><div id="section.i:PPUnits-39-" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:ShowDimSpec">ShowDimSpec</a> * x, <a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> xs) =&gt; <a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> ((:) * x xs)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> xs =&gt; <a href="DimMat-Internal.html#t:PPUnits-39-">PPUnits'</a> ((:) * <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> xs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ShowDimSpec" class="def">ShowDimSpec</a> a <span class="keyword">where</span> <a href="src/DimMat-Internal.html#ShowDimSpec" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:showDimSpec" class="def">showDimSpec</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> <a href="src/DimMat-Internal.html#showDimSpec" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ShowDimSpec" class="caption collapser" onclick="toggleSection('i:ShowDimSpec')">Instances</p><div id="section.i:ShowDimSpec" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a>), (~) * (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Dim">Dim</a> l m t i th n j) a) =&gt; <a href="DimMat-Internal.html#t:ShowDimSpec">ShowDimSpec</a> * a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:5">Constraints</h1><div class="doc"><p>A major theme in this library is that type inference goes in whichever direction
it can: in ordinary haskell it is very common for argument types to be determined
by the result types. For example see any code that uses <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Num">Num</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Read.html#t:Read">Read</a></code>.</p><p>When we use type families, things look more convenient:</p><pre>data Nat = S Nat | Z

type family Add (a :: Nat) (b :: Nat) :: Nat
type instance Add Z b = b
type instance Add (S a) b = Add a (S b)
</pre><p>But ghc is unable to deduce things like <code>a ~ Z</code> given evidence such as <code>Add Z a ~ Z</code>.
One way around this is to use <code>ConstraintKinds</code>:</p><pre>type AddT (a :: Nat) (b :: Nat) (c :: Nat)
          = (Add a b ~ c, Sub c a ~ b, Sub c b ~ a)
</pre><p>Which leads to functions like  <code>f :: AddT a b ab =&gt; ... </code>. This is bad for a couple reasons:</p><ul><li>the right-hand-side of the type can only mention type variables on the
  left-hand-side.</li><li>the left hand side can only bind type variables. Working around this
  leads to many auxiliary type families such as Fst, Snd and Head, or
  leads to a <code>type family AddT</code></li></ul><p>So below many constraints expressed as classes, since they have less
of those limitations.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:MultEq" class="def">MultEq</a> a b c <a href="src/DimMat-Internal.html#MultEq" class="link">Source</a></p><div class="doc"><p><code>a*b = c</code> when any are lists</p></div><div class="subs instances"><p id="control.i:MultEq" class="caption collapser" onclick="toggleSection('i:MultEq')">Instances</p><div id="section.i:MultEq" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:Mul">Mul</a> a b c =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> * * * a b c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:Zip1">Zip1</a> * <a href="DimMat-Internal.html#t:Mul">Mul</a> cs aInv b, <a href="DimMat-Internal.html#t:Mul">Mul</a> a aInv <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>) =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> * * [*] a b cs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Zip1">Zip1</a> * <a href="DimMat-Internal.html#t:Mul">Mul</a> bs a c =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> * [*] * a bs c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:Zip2">Zip2</a> * <a href="DimMat-Internal.html#t:Div">Div</a> bs cs aInv, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * bs cs, <a href="DimMat-Internal.html#t:Mul">Mul</a> a aInv <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>) =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> * [*] [*] a bs cs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Zip1">Zip1</a> * <a href="DimMat-Internal.html#t:Mul">Mul</a> as b c =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] * * as b c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * as cs, <a href="DimMat-Internal.html#t:Zip2">Zip2</a> * <a href="DimMat-Internal.html#t:Div">Div</a> as cs bInv, <a href="DimMat-Internal.html#t:Mul">Mul</a> b bInv <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>) =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] * [*] as b cs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * as bs, <a href="DimMat-Internal.html#t:Zip2">Zip2</a> * <a href="DimMat-Internal.html#t:Mul">Mul</a> as bs c) =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] [*] * as bs c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Zip3">Zip3</a> * <a href="DimMat-Internal.html#t:Mul">Mul</a> as bs cs =&gt; <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] [*] [*] as bs cs</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:6">Zip</h2><div class="top"><p class="src"><span class="keyword">class</span> (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a b, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> b c) =&gt; <a name="t:Zip3" class="def">Zip3</a> op a b c <a href="src/DimMat-Internal.html#Zip3" class="link">Source</a></p><div class="subs instances"><p id="control.i:Zip3" class="caption collapser" onclick="toggleSection('i:Zip3')">Instances</p><div id="section.i:Zip3" class="show"><table><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> k k aas bbs, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> k k ccs bbs, op a b c, (~) [k] ((:) k a as) aas, (~) [k] ((:) k b bs) bbs, (~) [k] ((:) k c cs) ccs, <a href="DimMat-Internal.html#t:Zip3">Zip3</a> k op as bs cs) =&gt; <a href="DimMat-Internal.html#t:Zip3">Zip3</a> k op aas bbs ccs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Zip3">Zip3</a> k op ([] k) ([] k) ([] k)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a b =&gt; <a name="t:Zip2" class="def">Zip2</a> op a b c <a href="src/DimMat-Internal.html#Zip2" class="link">Source</a></p><div class="subs instances"><p id="control.i:Zip2" class="caption collapser" onclick="toggleSection('i:Zip2')">Instances</p><div id="section.i:Zip2" class="show"><table><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> k k aas bbs, op a b c, (~) [k] ((:) k a as) aas, (~) [k] ((:) k b bs) bbs, <a href="DimMat-Internal.html#t:Zip2">Zip2</a> k op as bs c) =&gt; <a href="DimMat-Internal.html#t:Zip2">Zip2</a> k op aas bbs c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Zip2">Zip2</a> k op ([] k) ([] k) c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Zip1" class="def">Zip1</a> op a b c <a href="src/DimMat-Internal.html#Zip1" class="link">Source</a></p><div class="subs instances"><p id="control.i:Zip1" class="caption collapser" onclick="toggleSection('i:Zip1')">Instances</p><div id="section.i:Zip1" class="show"><table><tr><td class="src">((~) [k] ((:) k a as) aas, op a b c, <a href="DimMat-Internal.html#t:Zip1">Zip1</a> k op as b c) =&gt; <a href="DimMat-Internal.html#t:Zip1">Zip1</a> k op aas b c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Zip1">Zip1</a> k op ([] k) b c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a ab =&gt; <a name="t:Outer" class="def">Outer</a> a b ab <a href="src/DimMat-Internal.html#Outer" class="link">Source</a></p><div class="doc"><p>given <code>ijs :: [[Quantity a]]</code> (except the : and [] constructors are
actually (,) and (), ie. a HList that doesn't use the HList constructors),
calculate a <code>DimMat rowUnits colUnits</code>, where the outer product of rowUnits
and colUnits gives the units at each index in the ijs.  The first element
of colUnits is DOne.</p></div><div class="subs instances"><p id="control.i:Outer" class="caption collapser" onclick="toggleSection('i:Outer')">Instances</p><div id="section.i:Outer" class="show"><table><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> k1 k2 aas ccs, (~) [k2] ((:) k2 a as) aas, (~) [k1] ((:) k1 c cs) ccs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> k2 k k1 a b c, <a href="DimMat-Internal.html#t:Outer">Outer</a> k k1 k2 as b cs) =&gt; <a href="DimMat-Internal.html#t:Outer">Outer</a> k k k aas b ccs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Outer">Outer</a> k k k ([] k) b ([] k)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:7">DimMatFromTuple</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:DimMatFromTuple" class="def">DimMatFromTuple</a> ijs r1 r c e <a href="src/DimMat-Internal.html#DimMatFromTuple" class="link">Source</a></p><div class="subs instances"><p id="control.i:DimMatFromTuple" class="caption collapser" onclick="toggleSection('i:DimMatFromTuple')">Instances</p><div id="section.i:DimMatFromTuple" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:Outer">Outer</a> [*] [*] k ((:) k r1 r) ((:) * <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> c) ijs', <a href="DimMat-Internal.html#t:DMFromTuple1">DMFromTuple1</a> e ijs ijs', <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> [*] [*] (<a href="DimMat-Internal.html#t:TuplesToHListU">TuplesToHListU</a> ijs) ijs') =&gt; <a href="DimMat-Internal.html#t:DimMatFromTuple">DimMatFromTuple</a> * k [k] [*] * ijs r1 r c e</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:TupleToHListU" class="def">TupleToHListU</a> a :: [*] <a href="src/DimMat-Internal.html#TupleToHListU" class="link">Source</a></p><div class="subs instances"><p id="control.i:TupleToHListU" class="caption collapser" onclick="toggleSection('i:TupleToHListU')">Instances</p><div id="section.i:TupleToHListU" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:TupleToHListU">TupleToHListU</a> () = [] *</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:TupleToHListU">TupleToHListU</a> (a, b) = (:) * () (<a href="DimMat-Internal.html#t:TupleToHListU">TupleToHListU</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:TuplesToHListU" class="def">TuplesToHListU</a> a :: [[*]] <a href="src/DimMat-Internal.html#TuplesToHListU" class="link">Source</a></p><div class="subs instances"><p id="control.i:TuplesToHListU" class="caption collapser" onclick="toggleSection('i:TuplesToHListU')">Instances</p><div id="section.i:TuplesToHListU" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:TuplesToHListU">TuplesToHListU</a> () = [] [*]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:TuplesToHListU">TuplesToHListU</a> (a, b) = (:) [*] (<a href="DimMat-Internal.html#t:TupleToHListU">TupleToHListU</a> a) (<a href="DimMat-Internal.html#t:TuplesToHListU">TuplesToHListU</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:DMFromTuple1" class="def">DMFromTuple1</a> e b b' :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#DMFromTuple1" class="link">Source</a></p><div class="doc"><p>helper for <code><a href="DimMat-Internal.html#t:DimMatFromTuple">DimMatFromTuple</a></code></p></div><div class="subs instances"><p id="control.i:DMFromTuple1" class="caption collapser" onclick="toggleSection('i:DMFromTuple1')">Instances</p><div id="section.i:DMFromTuple1" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DMFromTuple1">DMFromTuple1</a> e () xs = (~) [[*]] xs ([] [*])</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DMFromTuple1">DMFromTuple1</a> e (x, xs) ((:) [*] x' xs') = (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * (<a href="DimMat-Internal.html#t:TupleToHListU">TupleToHListU</a> x) x', <a href="DimMat-Internal.html#t:DMFromTuple2">DMFromTuple2</a> e x x', <a href="DimMat-Internal.html#t:DMFromTuple1">DMFromTuple1</a> e xs xs')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:DMFromTuple2" class="def">DMFromTuple2</a> e b b' :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#DMFromTuple2" class="link">Source</a></p><div class="subs instances"><p id="control.i:DMFromTuple2" class="caption collapser" onclick="toggleSection('i:DMFromTuple2')">Instances</p><div id="section.i:DMFromTuple2" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DMFromTuple2">DMFromTuple2</a> e () xs = (~) [*] xs ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DMFromTuple2">DMFromTuple2</a> e (x, xs) ((:) * x' xs') = (<a href="DimMat-Internal.html#t:DMFromTuple3">DMFromTuple3</a> e x x', <a href="DimMat-Internal.html#t:DMFromTuple2">DMFromTuple2</a> e xs xs')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:DMFromTuple3" class="def">DMFromTuple3</a> e b b' :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#DMFromTuple3" class="link">Source</a></p><div class="subs instances"><p id="control.i:DMFromTuple3" class="caption collapser" onclick="toggleSection('i:DMFromTuple3')">Instances</p><div id="section.i:DMFromTuple3" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DMFromTuple3">DMFromTuple3</a> e (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> b e') b' = ((~) * e e', (~) * b b')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:toDM" class="def">toDM</a> :: <a href="DimMat-Internal.html#t:DimMatFromTuple">DimMatFromTuple</a> ijs r1 r c e =&gt; ijs -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` e) <a href="src/DimMat-Internal.html#toDM" class="link">Source</a></p><div class="doc"><p>just for types produced by the matD quasiquote</p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:InnerCxt" class="def">InnerCxt</a> t a b :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#InnerCxt" class="link">Source</a></p><div class="doc"><pre>InnerCxt t a b = t ~ <code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#v:dot">dot</a></code> a b</pre></div><div class="subs instances"><p id="control.i:InnerCxt" class="caption collapser" onclick="toggleSection('i:InnerCxt')">Instances</p><div id="section.i:InnerCxt" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:InnerCxt">InnerCxt</a> k t ([] k) ([] k) = ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:InnerCxt">InnerCxt</a> k t ((:) k a as) ((:) k b bs) = (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> k k k a b t, <a href="DimMat-Internal.html#t:InnerCxt">InnerCxt</a> k t as bs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> a b, <a href="DimMat-Internal.html#t:InnerCxt">InnerCxt</a> c a b) =&gt; <a name="t:Inner" class="def">Inner</a> a b c <a href="src/DimMat-Internal.html#Inner" class="link">Source</a></p><div class="subs instances"><p id="control.i:Inner" class="caption collapser" onclick="toggleSection('i:Inner')">Instances</p><div id="section.i:Inner" class="show"><table><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * aas bbs, <a href="DimMat-Internal.html#t:InnerCxt">InnerCxt</a> * c aas bbs) =&gt; <a href="DimMat-Internal.html#t:Inner">Inner</a> aas bbs c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ProdEq" class="def">ProdEq</a> a b <a href="src/DimMat-Internal.html#ProdEq" class="link">Source</a></p><div class="doc"><p><code>ProdEq a b</code> is <code>product a ~ b</code></p></div><div class="subs instances"><p id="control.i:ProdEq" class="caption collapser" onclick="toggleSection('i:ProdEq')">Instances</p><div id="section.i:ProdEq" class="show"><table><tr><td class="src">(~) * dOne <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> =&gt; <a href="DimMat-Internal.html#t:ProdEq">ProdEq</a> [k] * ([] k) dOne</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:ProdEq">ProdEq</a> [*] * as b', <a href="DimMat-Internal.html#t:Mul">Mul</a> a b' b) =&gt; <a href="DimMat-Internal.html#t:ProdEq">ProdEq</a> [*] * ((:) * a as) b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:RecipEq" class="def">RecipEq</a> a aInv <a href="src/DimMat-Internal.html#RecipEq" class="link">Source</a></p><div class="doc"><p><code>RecipEq a aInv</code> is <code>a*aInv ~ DOne</code> (or a list of DOne)</p></div><div class="subs instances"><p id="control.i:RecipEq" class="caption collapser" onclick="toggleSection('i:RecipEq')">Instances</p><div id="section.i:RecipEq" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:MultEq">MultEq</a> k k * as aInvs <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> =&gt; <a href="DimMat-Internal.html#t:RecipEq">RecipEq</a> k as aInvs</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:AtEq2" class="def">AtEq2</a> a n b m c :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#AtEq2" class="link">Source</a></p><div class="doc"><p><code>AtEq a n b m c</code> calculates <code>(At a n `Mult` At b m) ~ c</code>,
 but also can infer part of the <code>a</code> if the <code>b</code> and <code>c</code> are known</p></div><div class="subs instances"><p id="control.i:AtEq2" class="caption collapser" onclick="toggleSection('i:AtEq2')">Instances</p><div id="section.i:AtEq2" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> k as <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a> ((:) k b bs) (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> m) c = <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> k as <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a> bs m c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> k ((:) k a as) <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a> ((:) k b bs) <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a> c = <a href="DimMat-Internal.html#t:MultEq">MultEq</a> k k k a b c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> k ((:) k a as) (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) bs m c = <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> k as n bs m c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:AtEq" class="def">AtEq</a> a n b :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#AtEq" class="link">Source</a></p><div class="subs instances"><p id="control.i:AtEq" class="caption collapser" onclick="toggleSection('i:AtEq')">Instances</p><div id="section.i:AtEq" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AtEq">AtEq</a> k ((:) k a as) <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a> b = (~) k a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AtEq">AtEq</a> k ((:) k a as) (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> n) b = <a href="DimMat-Internal.html#t:AtEq">AtEq</a> k as n b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:-64--62-" class="def">(@&gt;)</a> :: (<a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> i, <a href="DimMat-Internal.html#t:AtEq">AtEq</a> r i ri, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> r1 ri u) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r]`)` a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> i -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> u a <a href="src/DimMat-Internal.html#%40%3E" class="link">Source</a></p><div class="doc"><p>Data.Packed.Vector.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Vector.html#v:-64--62-">@&gt;</a></code></p></div></div><div class="top"><p class="src"><a name="v:-64--64--62-" class="def">(@@&gt;)</a> :: (<a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> i, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> j, <a href="DimMat-Internal.html#t:AtEq2">AtEq2</a> (r1 : r) i (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : c) j ty) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> j) -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> ty a <a href="src/DimMat-Internal.html#%40%40%3E" class="link">Source</a></p><div class="doc"><p>Data.Packed.Matrix.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#v:-64--64--62-">@@&gt;</a></code></p></div></div><div class="top"><p class="src"><a name="v:pnorm" class="def">pnorm</a> :: (<a href="DimMat-Internal.html#t:AllEq">AllEq</a> r1 r, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> c) =&gt; <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:NormType">NormType</a> -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> r1 (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:RealOf">RealOf</a> a) <a href="src/DimMat-Internal.html#pnorm" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:AllEq" class="def">AllEq</a> a xs <a href="src/DimMat-Internal.html#AllEq" class="link">Source</a></p><div class="doc"><p><code>AllEq a xs</code> is like <code>all (all (a==)) xs</code>, <code>all (a ==) xs</code>, <code>a == xs</code>:
whichever amount of [ ] is peeled off before making the comparison (with ~)</p></div><div class="subs instances"><p id="control.i:AllEq" class="caption collapser" onclick="toggleSection('i:AllEq')">Instances</p><div id="section.i:AllEq" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:AllEq">AllEq</a> k [k] a ([] k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) k a x, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> k [k] a xs) =&gt; <a href="DimMat-Internal.html#t:AllEq">AllEq</a> k [k] a ((:) k x xs)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:AllEq">AllEq</a> [k] k ([] k) xs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:AllEq">AllEq</a> k1 k a xs, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> [k1] k as xs) =&gt; <a href="DimMat-Internal.html#t:AllEq">AllEq</a> [k] k ((:) k a as) xs</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Dot" class="def">Dot</a> a b c <span class="keyword">where</span> <a href="src/DimMat-Internal.html#Dot" class="link">Source</a></p><div class="doc"><p><code>c = a <code><a href="http://hackage.haskell.org/packages/archive/ansi-wl-pprint/0.6.7.1/doc/html/Text-PrettyPrint-ANSI-Leijen.html#v:dot">dot</a></code> b</code> is one of:</p><pre>c_ij = sum_j a_ij b_jk
c_k  = sum_j a_j  b_jk
c_i  = sum_j a_ij b_j
c    = sum_j a_j  b_j</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:dot" class="def">dot</a> :: <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Element">Element</a> e =&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e <a href="src/DimMat-Internal.html#dot" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Dot" class="caption collapser" onclick="toggleSection('i:Dot')">Instances</p><div id="section.i:Dot" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] * [*] ((:) * a ra) b ((:) * c rc), <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] [*] * ca rb b, (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) shA (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] a ((:) [*] ra ((:) [*] ca ([] [*])))), (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) shB (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] b ((:) [*] rb cb)), (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) shC (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] c ((:) [*] rc cb))) =&gt; <a href="DimMat-Internal.html#t:Dot">Dot</a> shA shB shC</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Trans" class="def">Trans</a> a b <span class="keyword">where</span> <a href="src/DimMat-Internal.html#Trans" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:trans" class="def">trans</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e <a href="src/DimMat-Internal.html#trans" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Trans" class="caption collapser" onclick="toggleSection('i:Trans')">Instances</p><div id="section.i:Trans" class="show"><table><tr><td class="src">((~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) a (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] x ((:) [*] y ([] [*])))), (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) b (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] y ((:) [*] x ([] [*]))))) =&gt; <a href="DimMat-Internal.html#t:Trans">Trans</a> a b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:PInv" class="def">PInv</a> a b <span class="keyword">where</span> <a href="src/DimMat-Internal.html#PInv" class="link">Source</a></p><div class="doc"><p>type for a pseudoinverse (and inverse):</p><p>The single instance comes from looking at inverses from a 2x2 matrix (let's call A):</p><pre>a b
c d</pre><p>and the inverse * determinant of the original</p><pre> d  -b
-c   a</pre><p>In the product A * A^-1 the diagonal is dimensionless (<code><a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a></code>).</p><p>That happens if the row and column type-level unit lists are reciprocals of
eachother (<code><a href="DimMat-Internal.html#t:AreRecips">AreRecips</a></code>), so the constraint on the instance of PInv encodes
this exactly (plus some constraints requiring that sh and sh' are at least
1x1)</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:pinv" class="def">pinv</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e <a href="src/DimMat-Internal.html#pinv" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:PInv" class="caption collapser" onclick="toggleSection('i:PInv')">Instances</p><div id="section.i:PInv" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] [*] * ra cb a, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] [*] * ca rb b, <a href="DimMat-Internal.html#t:AreRecips">AreRecips</a> * * a b, (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) bSh (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] b ((:) [*] rb ((:) [*] cb ([] [*])))), (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) aSh (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] a ((:) [*] ra ((:) [*] ca ([] [*]))))) =&gt; <a href="DimMat-Internal.html#t:PInv">PInv</a> aSh bSh</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:LengthSndTwo" class="def">LengthSndTwo</a> a :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#LengthSndTwo" class="link">Source</a></p><div class="subs instances"><p id="control.i:LengthSndTwo" class="caption collapser" onclick="toggleSection('i:LengthSndTwo')">Instances</p><div id="section.i:LengthSndTwo" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:LengthSndTwo">LengthSndTwo</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> k1 [k]) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> k1 [k] a as) = <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * k as ((:) * () ((:) * () ([] *)))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:AreRecips" class="def">AreRecips</a> a b = <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a b <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> <a href="src/DimMat-Internal.html#AreRecips" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:inv" class="def">inv</a> :: (<a href="DimMat-Internal.html#t:PInv">PInv</a> a b, b ~ `(t1, `[t2, t3]`)`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e <a href="src/DimMat-Internal.html#inv" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:pinvTol" class="def">pinvTol</a> :: (<a href="DimMat-Internal.html#t:PInv">PInv</a> a b, b ~ `(t1, `[t2, t3]`)`) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e <a href="src/DimMat-Internal.html#pinvTol" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Det" class="def">Det</a> a b <span class="keyword">where</span> <a href="src/DimMat-Internal.html#Det" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:det" class="def">det</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> b e <a href="src/DimMat-Internal.html#det" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Det" class="caption collapser" onclick="toggleSection('i:Det')">Instances</p><div id="section.i:Det" class="show"><table><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * r c, <a href="DimMat-Internal.html#t:ProdEq">ProdEq</a> [*] * ((:) * r1 r) pr, <a href="DimMat-Internal.html#t:ProdEq">ProdEq</a> [*] * c pc, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> * * * pr pc b, (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) a (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] r ((:) [*] c ([] [*]))))) =&gt; <a href="DimMat-Internal.html#t:Det">Det</a> a b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:expm" class="def">expm</a> :: <a href="DimMat-Internal.html#t:AreRecips">AreRecips</a> r c =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(r1, `[r, c]`)` a <a href="src/DimMat-Internal.html#expm" class="link">Source</a></p><div class="doc"><p>Numeric.LinearAlgebra.Algorithms.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#v:expm">expm</a></code></p><p><code>y t = expm (scale t a) `multiply` y0</code> solves the DE <code>y' = Ay</code> where y0 is the
value of y at time 0</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Scale" class="def">Scale</a> a b c <span class="keyword">where</span> <a href="src/DimMat-Internal.html#Scale" class="link">Source</a></p><div class="doc"><p>Numeric.Container.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#v:scale">scale</a></code></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:scale" class="def">scale</a> ::  <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e <a href="src/DimMat-Internal.html#scale" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Scale" class="caption collapser" onclick="toggleSection('i:Scale')">Instances</p><div id="section.i:Scale" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:MultEq">MultEq</a> * [*] [*] a ((:) * r1 r) ((:) * r1' r'), (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) b (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] r rs)), (~) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#t:-40--44--41-">(,)</a> * [[*]]) c (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1' ((:) [*] r' rs))) =&gt; <a href="DimMat-Internal.html#t:Scale">Scale</a> a b c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:fromQty" class="def">fromQty</a> :: <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e =&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e <a href="src/DimMat-Internal.html#fromQty" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:toQty" class="def">toQty</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e <a href="src/DimMat-Internal.html#toQty" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ScaleRecip" class="def">ScaleRecip</a> a b c <span class="keyword">where</span> <a href="src/DimMat-Internal.html#ScaleRecip" class="link">Source</a></p><div class="doc"><p>Numeric.Container.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#v:scaleRecip">scaleRecip</a></code></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:scaleRecip" class="def">scaleRecip</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e <a href="src/DimMat-Internal.html#scaleRecip" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ScaleRecip" class="caption collapser" onclick="toggleSection('i:ScaleRecip')">Instances</p><div id="section.i:ScaleRecip" class="show"><table><tr><td class="src">((~) <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> bool1 (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Type-Equality.html#t:-61--61-">(==)</a> <a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> [*] bs) (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a>))), (~) <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> bool2 (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Type-Equality.html#t:-61--61-">(==)</a> <a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> [*] cs) (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> (<a href="../HList/Data-HList-FakePrelude.html#v:HSucc">HSucc</a> <a href="../HList/Data-HList-FakePrelude.html#v:HZero">HZero</a>))), (~) <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> bool1 bool2, <a href="DimMat-Internal.html#t:ScaleRecip1">ScaleRecip1</a> bool1 a (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] b bs) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] c cs)) =&gt; <a href="DimMat-Internal.html#t:ScaleRecip">ScaleRecip</a> a (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] b bs) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] c cs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ScaleRecip1" class="def">ScaleRecip1</a> bool a b c <span class="keyword">where</span> <a href="src/DimMat-Internal.html#ScaleRecip1" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:scaleRecip1" class="def">scaleRecip1</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> bool -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e <a href="src/DimMat-Internal.html#scaleRecip1" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ScaleRecip1" class="caption collapser" onclick="toggleSection('i:ScaleRecip1')">Instances</p><div id="section.i:ScaleRecip1" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:ScaleRecipCxt">ScaleRecipCxt</a> r1 r1' r r' rs rs' a b c, (~) [[*]] rs' ([] [*])) =&gt; <a href="DimMat-Internal.html#t:ScaleRecip1">ScaleRecip1</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a> a b c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:ScaleRecipCxt">ScaleRecipCxt</a> r1 r1' r r' rs rs' a b c, (~) [[*]] rs' ((:) [*] t1 ([] [*]))) =&gt; <a href="DimMat-Internal.html#t:ScaleRecip1">ScaleRecip1</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a> a b c</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ScaleRecipCxt" class="def">ScaleRecipCxt</a> r1 r1' r r' rs rs' a b c = (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> a (r1' : r') (r1 : r), <a href="DimMat-Internal.html#t:MultEq">MultEq</a> rs rs' <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>, b ~ `(r1, r : rs)`, c ~ `(r1', r' : rs')`) <a href="src/DimMat-Internal.html#ScaleRecipCxt" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:recipMat" class="def">recipMat</a> :: <span class="keyword">forall</span> b c e. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="DimMat-Internal.html#t:ScaleRecip">ScaleRecip</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> b c) =&gt; <a href="DimMat-Internal.html#t:D">D</a> b e -&gt; <a href="DimMat-Internal.html#t:D">D</a> c e <a href="src/DimMat-Internal.html#recipMat" class="link">Source</a></p><div class="doc"><p>a shortcut for <code>scaleRecip (DScal 1)</code></p></div></div><div class="top"><p class="src"><a name="v:liftH2" class="def">liftH2</a> ::  (<span class="keyword">forall</span> h f. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#t:Container">Container</a> f e, h ~ f e) =&gt; h -&gt; h -&gt; h) -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e <a href="src/DimMat-Internal.html#liftH2" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:add" class="def">add</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e <a href="src/DimMat-Internal.html#add" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:sub" class="def">sub</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e <a href="src/DimMat-Internal.html#sub" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:mulMat" class="def">mulMat</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as bs cs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a b c, cs ~ `[t1, t2]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e <a href="src/DimMat-Internal.html#mulMat" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:mulVec" class="def">mulVec</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as bs cs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a b c, cs ~ `[t1]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e <a href="src/DimMat-Internal.html#mulVec" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:divideMat" class="def">divideMat</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as cs bs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a c b, cs ~ `[t1, t2]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e <a href="src/DimMat-Internal.html#divideMat" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:divideVec" class="def">divideVec</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> as cs bs, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> a c b, cs ~ `[t1]`) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(c, cs)` e <a href="src/DimMat-Internal.html#divideVec" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:arctan2" class="def">arctan2</a> :: (bs ~ <a href="DimMat-Internal.html#t:MapMapConst">MapMapConst</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> as) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, bs)` e <a href="src/DimMat-Internal.html#arctan2" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:equal" class="def">equal</a> ::  <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="src/DimMat-Internal.html#equal" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:CMap" class="def">CMap</a> f a b e e' <span class="keyword">where</span> <a href="src/DimMat-Internal.html#CMap" class="link">Source</a></p><div class="doc"><p><code>cmap f m</code> gives a matrix <code>m'</code></p><p><code>f</code> is applied to </p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:cmap" class="def">cmap</a> :: f -&gt; <a href="DimMat-Internal.html#t:D">D</a> a e -&gt; <a href="DimMat-Internal.html#t:D">D</a> b e' <a href="src/DimMat-Internal.html#cmap" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:CMap" class="caption collapser" onclick="toggleSection('i:CMap')">Instances</p><div id="section.i:CMap" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:ToHLists">ToHLists</a> sh e xs, <a href="DimMat-Internal.html#t:FromHLists">FromHLists</a> xs' sh' e', <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * xs xs', <a href="../HList/Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="../HList/Data-HList-HList.html#t:HMap">HMap</a> f) xs xs') =&gt; <a href="DimMat-Internal.html#t:CMap">CMap</a> f sh sh' e e'</td><td class="doc"><p>Maybe there's a way to implement in terms of the real cmap (possibly
 unsafeCoerce?)</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:AppendEq-39-" class="def">AppendEq'</a> a b ab :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#AppendEq%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:AppendEq-39-" class="caption collapser" onclick="toggleSection('i:AppendEq-39-')">Instances</p><div id="section.i:AppendEq-39-" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AppendEq-39-">AppendEq'</a> k ([] k) b abs = (~) [k] b abs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AppendEq-39-">AppendEq'</a> k ((:) k a as) b ((:) k a' abs) = ((~) k a a', <a href="DimMat-Internal.html#t:AppendEq-39-">AppendEq'</a> k as b abs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:AppendEq" class="def">AppendEq</a> a b ab = (ab ~ <a href="../HList/Data-HList-HListPrelude.html#t:HAppendR">HAppendR</a> a b, <a href="DimMat-Internal.html#t:AppendEq-39-">AppendEq'</a> a b ab, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> a ab) b, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> b ab) a) <a href="src/DimMat-Internal.html#AppendEq" class="link">Source</a></p><div class="doc"><p>a bit overkill?
  <code>a ++ b = ab</code></p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:DropPrefix" class="def">DropPrefix</a> a ab :: [k] <a href="src/DimMat-Internal.html#DropPrefix" class="link">Source</a></p><div class="subs instances"><p id="control.i:DropPrefix" class="caption collapser" onclick="toggleSection('i:DropPrefix')">Instances</p><div id="section.i:DropPrefix" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> k ([] k) bs = bs</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> k ((:) k a as) ((:) k a' abs) = <a href="DimMat-Internal.html#t:DropPrefix">DropPrefix</a> k as abs</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hconcat" class="def">hconcat</a> :: (<a href="DimMat-Internal.html#t:MultEq">MultEq</a> (rem :: *) a b, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> rem ra rb, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> rem (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : cb) cb', <a href="DimMat-Internal.html#t:AppendEq">AppendEq</a> ca cb' cc) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, ca]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, `[rb, cb]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, cc]`)` e <a href="src/DimMat-Internal.html#hconcat" class="link">Source</a></p><div class="doc"><p>the slightly involved type here exists because
ci1 and ci2 both start with DOne, but ci2's contribution
to ci3 does not need a DOne at the start. Another way to
read the constraints here is:</p><pre>map (*rem) (a11 : ri) = b11 : bi
ci3 = ci1 ++ map (*rem) ci2</pre><p>The same idea happens with vconcat.</p></div></div><div class="top"><p class="src"><a name="v:vconcat" class="def">vconcat</a> :: <a href="DimMat-Internal.html#t:AppendEq">AppendEq</a> ra (b : rb) rc =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, ca]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(b, `[rb, ca]`)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[rc, ca]`)` e <a href="src/DimMat-Internal.html#vconcat" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:rank" class="def">rank</a> ::  <a href="DimMat-Internal.html#t:D">D</a> t a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="src/DimMat-Internal.html#rank" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:cols" class="def">cols</a> ::  <a href="DimMat-Internal.html#t:D">D</a> t a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="src/DimMat-Internal.html#cols" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:rows" class="def">rows</a> ::  <a href="DimMat-Internal.html#t:D">D</a> t a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="src/DimMat-Internal.html#rows" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:rowsNT" class="def">rowsNT</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, r : c)` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (a : ri)) <a href="src/DimMat-Internal.html#rowsNT" class="link">Source</a></p><div class="doc"><p>H.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#v:rows">rows</a></code> except type-level</p></div></div><div class="top"><p class="src"><a name="v:colsNT" class="def">colsNT</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, r : (c : cs))` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : c)) <a href="src/DimMat-Internal.html#colsNT" class="link">Source</a></p><div class="doc"><p>H.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#v:cols">cols</a></code> except type-level</p></div></div><div class="top"><p class="src"><a name="v:hasRows" class="def">hasRows</a> :: (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="../HList/Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n ()) r, <a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> r ~ n) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : ca)` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (n :: <a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a>) -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : ca)` e <a href="src/DimMat-Internal.html#hasRows" class="link">Source</a></p><div class="doc"><p>(m <code><a href="DimMat-Internal.html#v:hasRows">hasRows</a></code> n) constrains the matrix/vector <code>m</code> to have <code>n</code> rows</p></div></div><div class="top"><p class="src"><a name="v:hasCols" class="def">hasCols</a> :: (<a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> (<a href="../HList/Data-HList-HList.html#t:HReplicateR">HReplicateR</a> n ()) ci, <a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> ci ~ n) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : (ca : rest))` e -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Proxy.html#t:Proxy">Proxy</a> (n :: <a href="../HList/Data-HList-FakePrelude.html#t:HNat">HNat</a>) -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, ra : (ca : rest))` e <a href="src/DimMat-Internal.html#hasCols" class="link">Source</a></p><div class="doc"><p>(m <code><a href="DimMat-Internal.html#v:hasRows">hasRows</a></code> n) constrains the matrix/vector <code>m</code> to have <code>n</code> rows</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="DimMat-Internal.html#t:MapConst">MapConst</a> [] as ~ as) =&gt; <a name="t:Scalar" class="def">Scalar</a> as <span class="keyword">where</span> <a href="src/DimMat-Internal.html#Scalar" class="link">Source</a></p><div class="doc"><p>H.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#v:scalar">scalar</a></code></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:scalar" class="def">scalar</a> ::  <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, as)` e <a href="src/DimMat-Internal.html#scalar" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Scalar" class="caption collapser" onclick="toggleSection('i:Scalar')">Instances</p><div id="section.i:Scalar" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:Scalar">Scalar</a> ((:) [*] ([] *) ((:) [*] ([] *) ([] [*])))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="DimMat-Internal.html#t:Scalar">Scalar</a> ((:) [*] ([] *) ([] [*]))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:konst" class="def">konst</a> :: <span class="keyword">forall</span> e a ra ca. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (a : ra)), <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : ca)), <a href="DimMat-Internal.html#t:AllEq">AllEq</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> ca, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> a ra) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[ra, ca]`)` e <a href="src/DimMat-Internal.html#konst" class="link">Source</a></p><div class="doc"><p>Numeric.Container.<code><a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-Container.html#v:konst">konst</a></code>, but the size is determined by the type.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let n = hSucc (hSucc hZero) -- 2
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>konst ((1::Double) *~ second) `hasRows` n `hasCols` n
</code></strong>2&gt;&lt;2 1   1  
s    1.0 1.0
s    1.0 1.0
</pre></div></div><div class="top"><p class="src"><a name="v:ident" class="def">ident</a> :: <span class="keyword">forall</span> ones e. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : ones))) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a>, `[ones, ones]`)` e <a href="src/DimMat-Internal.html#ident" class="link">Source</a></p><div class="doc"><p>identity matrix. The size is determined by the type.</p></div></div><div class="top"><p class="src"><a name="v:zeroes" class="def">zeroes</a> :: <span class="keyword">forall</span> c a r e. (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (a : r)), <a href="../HList/Data-HList-FakePrelude.html#t:HNat2Integral">HNat2Integral</a> (<a href="../HList/Data-HList-HList.html#t:HLength">HLength</a> (<a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> : c))) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[r, c]`)` e <a href="src/DimMat-Internal.html#zeroes" class="link">Source</a></p><div class="doc"><p>zero matrix. The size and dimension is determined by the type.</p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:CanAddConst" class="def">CanAddConst</a> a m :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#CanAddConst" class="link">Source</a></p><div class="subs instances"><p id="control.i:CanAddConst" class="caption collapser" onclick="toggleSection('i:CanAddConst')">Instances</p><div id="section.i:CanAddConst" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:CanAddConst">CanAddConst</a> k a ((:) [k] as ([] [k])) = <a href="DimMat-Internal.html#t:AllEq">AllEq</a> k [k] a as</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:CanAddConst">CanAddConst</a> k a ((:) [k] as ((:) [k] ones ([] [k]))) = (<a href="DimMat-Internal.html#t:AllEq">AllEq</a> k [k] a as, <a href="DimMat-Internal.html#t:AllEq">AllEq</a> [<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Prim.html#t:AnyK">AnyK</a>] [k] ([] <a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Prim.html#t:AnyK">AnyK</a>) ones)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:addConstant" class="def">addConstant</a> :: (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="DimMat-Internal.html#t:CanAddConst">CanAddConst</a> a sh) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, [])` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e <a href="src/DimMat-Internal.html#addConstant" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:conj" class="def">conj</a> ::  <a href="DimMat-Internal.html#t:D">D</a> sh a -&gt; <a href="DimMat-Internal.html#t:D">D</a> sh a <a href="src/DimMat-Internal.html#conj" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:ctrans" class="def">ctrans</a> ::  <a href="DimMat-Internal.html#t:D">D</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] x ((:) [*] y ([] [*])))) a -&gt; <a href="DimMat-Internal.html#t:D">D</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] y ((:) [*] x ([] [*])))) a <a href="src/DimMat-Internal.html#ctrans" class="link">Source</a></p><div class="doc"><p>conjugate transpose</p></div></div><div class="top"><p class="src"><a name="v:diag" class="def">diag</a> :: (<a href="DimMat-Internal.html#t:MapConst">MapConst</a> <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> r ~ c, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> r c) =&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[r]`)` t -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, `[r, c]`)` t <a href="src/DimMat-Internal.html#diag" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:diagBlock" class="def">diagBlock</a> :: (<a href="../HList/Data-HList-HList.html#t:HMapOut">HMapOut</a> <a href="DimMat-Internal.html#t:UnDimMat">UnDimMat</a> (b : bs) (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> e), <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Num">Num</a> e, <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="DimMat-Internal.html#t:AppendShOf">AppendShOf</a> b bs (<a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e), sh ~ `[r, c]`) =&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> (b : bs) -&gt; <a href="DimMat-Internal.html#t:D">D</a> `(a, sh)` e <a href="src/DimMat-Internal.html#diagBlock" class="link">Source</a></p><div class="doc"><p><code><a href="H.html#v:blockDiag">blockDiag</a></code>. The blocks should be provided as:</p><pre>blockDiag $ <code><a href="../HList/Data-HList-HList.html#v:hBuild">hBuild</a></code> m1 m2 m3</pre><p>only available if hmatrix &gt;= 0.15</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:UnDimMat" class="def">UnDimMat</a> <a href="src/DimMat-Internal.html#UnDimMat" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:UnDimMat" class="def">UnDimMat</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:UnDimMat" class="caption collapser" onclick="toggleSection('i:UnDimMat')">Instances</p><div id="section.i:UnDimMat" class="show"><table><tr><td class="src">((~) * (<a href="DimMat-Internal.html#t:D">D</a> sh a) x, (~) * (<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Data-Packed-Matrix.html#t:Matrix">Matrix</a> a) y) =&gt; <a href="../HList/Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="DimMat-Internal.html#t:UnDimMat">UnDimMat</a> x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:DiagBlock" class="def">DiagBlock</a> bs t <a href="src/DimMat-Internal.html#DiagBlock" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:AppendShOf" class="def">AppendShOf</a> a as aas <a href="src/DimMat-Internal.html#AppendShOf" class="link">Source</a></p><div class="doc"><p><code>AppendShOf a [b,c,d] aas</code> makes aas have the type of a matrix that
 has a,b,c,d along the diagonal</p></div><div class="subs instances"><p id="control.i:AppendShOf" class="caption collapser" onclick="toggleSection('i:AppendShOf')">Instances</p><div id="section.i:AppendShOf" class="show"><table><tr><td class="src">(~) k x z =&gt; <a href="DimMat-Internal.html#t:AppendShOf">AppendShOf</a> k k x ([] *) z</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * e f, (~) * f g, <a href="DimMat-Internal.html#t:AppendShOf">AppendShOf</a> * * (<a href="DimMat-Internal.html#t:D">D</a> ab e) ds z, <a href="DimMat-Internal.html#t:AppendDims">AppendDims</a> a b ab, (~) * x (<a href="DimMat-Internal.html#t:D">D</a> a e), (~) * y (<a href="DimMat-Internal.html#t:D">D</a> b f), (~) * z (<a href="DimMat-Internal.html#t:D">D</a> c g)) =&gt; <a href="DimMat-Internal.html#t:AppendShOf">AppendShOf</a> * * x ((:) * y ds) z</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:AppendDims" class="def">AppendDims</a> a b c :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#AppendDims" class="link">Source</a></p><div class="subs instances"><p id="control.i:AppendDims" class="caption collapser" onclick="toggleSection('i:AppendDims')">Instances</p><div id="section.i:AppendDims" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:AppendDims">AppendDims</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] a ((:) [*] ra ((:) [*] ca ([] [*])))) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] b ((:) [*] rb ((:) [*] cb ([] [*])))) (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] c ((:) [*] rc ((:) [*] cc ([] [*])))) = ((~) * c a, <a href="DimMat-Internal.html#t:AppendEq">AppendEq</a> * ra ((:) * b rb) rc, <a href="DimMat-Internal.html#t:AppendEq">AppendEq</a> * ca cb cc)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToHList" class="def">ToHList</a> sh e result <span class="keyword">where</span> <a href="src/DimMat-Internal.html#ToHList" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toHList" class="def">toHList</a> :: <a href="DimMat-Internal.html#t:D">D</a> sh e -&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> result <a href="src/DimMat-Internal.html#toHList" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ToHList" class="caption collapser" onclick="toggleSection('i:ToHList')">Instances</p><div id="section.i:ToHList" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:HListFromList">HListFromList</a> e e1, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * result e1, <a href="../HList/Data-HList-HList.html#t:HMapAux">HMapAux</a> <a href="DimMat-Internal.html#t:AddDimensional">AddDimensional</a> e1 result, <a href="DimMat-Internal.html#t:ToHListRow">ToHListRow</a> ((:) * r rs) e result) =&gt; <a href="DimMat-Internal.html#t:ToHList">ToHList</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r ((:) [*] rs ([] [*]))) e result</td><td class="doc"><p>given a vector like <code>x = DimMat '[units] e</code> this does something like
 <code>[ (x @&gt; i) | i &lt;- [1 .. n] ]</code>, if we had comprehensions for HLists</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HListFromList" class="def">HListFromList</a> e e' <span class="keyword">where</span> <a href="src/DimMat-Internal.html#HListFromList" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hListFromList" class="def">hListFromList</a> :: [e] -&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> e' <a href="src/DimMat-Internal.html#hListFromList" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HListFromList" class="caption collapser" onclick="toggleSection('i:HListFromList')">Instances</p><div id="section.i:HListFromList" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:HListFromList">HListFromList</a> e ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * e e', <a href="DimMat-Internal.html#t:HListFromList">HListFromList</a> e es) =&gt; <a href="DimMat-Internal.html#t:HListFromList">HListFromList</a> e ((:) * e' es)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:ToHListRow" class="def">ToHListRow</a> a e b :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Exts.html#t:Constraint">Constraint</a> <a href="src/DimMat-Internal.html#ToHListRow" class="link">Source</a></p><div class="subs instances"><p id="control.i:ToHListRow" class="caption collapser" onclick="toggleSection('i:ToHListRow')">Instances</p><div id="section.i:ToHListRow" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:ToHListRow">ToHListRow</a> ((:) * a as) e ((:) * b bs) = ((~) * (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> a e) b, <a href="DimMat-Internal.html#t:ToHListRow">ToHListRow</a> as e bs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:AddDimensional" class="def">AddDimensional</a> <a href="src/DimMat-Internal.html#AddDimensional" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AddDimensional" class="def">AddDimensional</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:AddDimensional" class="caption collapser" onclick="toggleSection('i:AddDimensional')">Instances</p><div id="section.i:AddDimensional" class="show"><table><tr><td class="src">(~) * (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> t x) y =&gt; <a href="../HList/Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="DimMat-Internal.html#t:AddDimensional">AddDimensional</a> x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:FromHList" class="def">FromHList</a> list sh e <span class="keyword">where</span> <a href="src/DimMat-Internal.html#FromHList" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:fromHList" class="def">fromHList</a> :: <a href="../HList/Data-HList-HList.html#t:HList">HList</a> list -&gt; <a href="DimMat-Internal.html#t:D">D</a> sh e <a href="src/DimMat-Internal.html#fromHList" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:FromHList" class="caption collapser" onclick="toggleSection('i:FromHList')">Instances</p><div id="section.i:FromHList" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e, <a href="../HList/Data-HList-HList.html#t:HMapOut">HMapOut</a> <a href="DimMat-Internal.html#t:RmDimensional">RmDimensional</a> list e, <a href="DimMat-Internal.html#t:ToHListRow">ToHListRow</a> ((:) * r rs) e list) =&gt; <a href="DimMat-Internal.html#t:FromHList">FromHList</a> list (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r ((:) [*] rs ([] [*]))) e</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:RmDimensional" class="def">RmDimensional</a> <a href="src/DimMat-Internal.html#RmDimensional" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:RmDimensional" class="def">RmDimensional</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:RmDimensional" class="caption collapser" onclick="toggleSection('i:RmDimensional')">Instances</p><div id="section.i:RmDimensional" class="show"><table><tr><td class="src">(~) * x (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> d y) =&gt; <a href="../HList/Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="DimMat-Internal.html#t:RmDimensional">RmDimensional</a> x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:FromHLists" class="def">FromHLists</a> lists sh e <span class="keyword">where</span> <a href="src/DimMat-Internal.html#FromHLists" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:fromHLists" class="def">fromHLists</a> :: <a href="../HList/Data-HList-HList.html#t:HList">HList</a> lists -&gt; <a href="DimMat-Internal.html#t:D">D</a> sh e <a href="src/DimMat-Internal.html#fromHLists" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:FromHLists" class="caption collapser" onclick="toggleSection('i:FromHLists')">Instances</p><div id="section.i:FromHLists" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:ToHListRows-39-">ToHListRows'</a> ((:) * r1 r) c e lists, <a href="../HList/Data-HList-HList.html#t:HMapOut">HMapOut</a> (<a href="DimMat-Internal.html#t:HMapOutWith">HMapOutWith</a> <a href="DimMat-Internal.html#t:RmDimensional">RmDimensional</a>) lists [e], <a href="http://hackage.haskell.org/packages/archive/hmatrix/0.15.2.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#t:Field">Field</a> e) =&gt; <a href="DimMat-Internal.html#t:FromHLists">FromHLists</a> lists (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] r ((:) [*] c ([] [*])))) e</td><td class="doc"><dl><dt>[Dim e unit</dt><dd>] -&gt; DimMat units e</dd></dl></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:HMapOutWith" class="def">HMapOutWith</a> f <a href="src/DimMat-Internal.html#HMapOutWith" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HMapOutWith" class="def">HMapOutWith</a> f</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HMapOutWith" class="caption collapser" onclick="toggleSection('i:HMapOutWith')">Instances</p><div id="section.i:HMapOutWith" class="show"><table><tr><td class="src">(<a href="../HList/Data-HList-HList.html#t:HMapOut">HMapOut</a> f l e, (~) * es [e], (~) * (<a href="../HList/Data-HList-HList.html#t:HList">HList</a> l) hl) =&gt; <a href="../HList/Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="DimMat-Internal.html#t:HMapOutWith">HMapOutWith</a> f) hl es</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToHListRows-39-" class="def">ToHListRows'</a> r c e rows <a href="src/DimMat-Internal.html#ToHListRows%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:ToHListRows-39-" class="caption collapser" onclick="toggleSection('i:ToHListRows-39-')">Instances</p><div id="section.i:ToHListRows-39-" class="show"><table><tr><td class="src"><a href="DimMat-Internal.html#t:ToHListRows-39-">ToHListRows'</a> ([] *) c e ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="DimMat-Internal.html#t:ToHListRows-39-">ToHListRows'</a> r c e rows, <a href="DimMat-Internal.html#t:MultEq">MultEq</a> [*] [*] [*] r c c', <a href="../HList/Data-HList-HList.html#t:HMapCxt">HMapCxt</a> (<a href="DimMat-Internal.html#t:AddQty">AddQty</a> * e) (<a href="../HList/Data-HList-HList.html#t:HList">HList</a> c') hListRow c' row') =&gt; <a href="DimMat-Internal.html#t:ToHListRows-39-">ToHListRows'</a> ((:) * r1 r) c e ((:) * hListRow rows)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:AddQty" class="def">AddQty</a> u <a href="src/DimMat-Internal.html#AddQty" class="link">Source</a></p><div class="subs instances"><p id="control.i:AddQty" class="caption collapser" onclick="toggleSection('i:AddQty')">Instances</p><div id="section.i:AddQty" class="show"><table><tr><td class="src">(~) * qty (<a href="../dimensional/Numeric-Units-Dimensional.html#t:Quantity">Quantity</a> u e) =&gt; <a href="../HList/Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> (<a href="DimMat-Internal.html#t:AddQty">AddQty</a> * u) e qty</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToHLists" class="def">ToHLists</a> sh e xs <span class="keyword">where</span> <a href="src/DimMat-Internal.html#ToHLists" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toHLists" class="def">toHLists</a> :: <a href="DimMat-Internal.html#t:D">D</a> sh e -&gt; <a href="../HList/Data-HList-HList.html#t:HList">HList</a> xs <a href="src/DimMat-Internal.html#toHLists" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ToHLists" class="caption collapser" onclick="toggleSection('i:ToHLists')">Instances</p><div id="section.i:ToHLists" class="show"><table><tr><td class="src">(<a href="DimMat-Internal.html#t:HListFromList">HListFromList</a> e e1, <a href="DimMat-Internal.html#t:HListFromList">HListFromList</a> (<a href="../HList/Data-HList-HList.html#t:HList">HList</a> e1) e2, <a href="../HList/Data-HList-HList.html#t:HMapAux">HMapAux</a> (<a href="../HList/Data-HList-HList.html#t:HMap">HMap</a> <a href="DimMat-Internal.html#t:AddDimensional">AddDimensional</a>) e2 xs, <a href="DimMat-Internal.html#t:ToHListRows-39-">ToHListRows'</a> ri ci e xs, <a href="../HList/Data-HList-HList.html#t:SameLength">SameLength</a> * * e2 xs, (~) [*] ((:) * r1 r) ri, (~) [*] ((:) * <a href="../dimensional/Numeric-Units-Dimensional.html#t:DOne">DOne</a> c) ci) =&gt; <a href="DimMat-Internal.html#t:ToHLists">ToHLists</a> (<a href="http://hackage.haskell.org/packages/archive/ghc-prim/0.3.1.0/doc/html/GHC-Tuple.html#v:-40--44--41-">(,)</a> * [[*]] r1 ((:) [*] r ((:) [*] c ([] [*])))) e xs</td><td class="doc"><p>DimMat units e -&gt; [[Dim e unit]]</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:MapMapConst" class="def">MapMapConst</a> a xs :: [[k]] <a href="src/DimMat-Internal.html#MapMapConst" class="link">Source</a></p><div class="doc"><pre>\a xs -&gt; map (map (const a)) xs</pre></div><div class="subs instances"><p id="control.i:MapMapConst" class="caption collapser" onclick="toggleSection('i:MapMapConst')">Instances</p><div id="section.i:MapMapConst" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:MapMapConst">MapMapConst</a> k k1 a ([] [k1]) = [] [k]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:MapMapConst">MapMapConst</a> k k1 a ((:) [k1] x xs) = (:) [k] (<a href="DimMat-Internal.html#t:MapConst">MapConst</a> k k1 a x) (<a href="DimMat-Internal.html#t:MapMapConst">MapMapConst</a> k k1 a xs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:MapConst" class="def">MapConst</a> a xs :: [k] <a href="src/DimMat-Internal.html#MapConst" class="link">Source</a></p><div class="doc"><pre>\a xs -&gt; map (const a) xs</pre></div><div class="subs instances"><p id="control.i:MapConst" class="caption collapser" onclick="toggleSection('i:MapConst')">Instances</p><div id="section.i:MapConst" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:MapConst">MapConst</a> k k1 a ([] k1) = [] k</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:MapConst">MapConst</a> k k1 a ((:) k1 x xs) = (:) k a (<a href="DimMat-Internal.html#t:MapConst">MapConst</a> k k1 a xs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:FromPairs" class="def">FromPairs</a> a :: [*] <a href="src/DimMat-Internal.html#FromPairs" class="link">Source</a></p><div class="doc"><p>convert from (a,(b,(c,(d,())))) to '[a,b,c,d]</p></div><div class="subs instances"><p id="control.i:FromPairs" class="caption collapser" onclick="toggleSection('i:FromPairs')">Instances</p><div id="section.i:FromPairs" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:FromPairs">FromPairs</a> () = [] *</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="DimMat-Internal.html#t:FromPairs">FromPairs</a> (a, b) = (:) * a (<a href="DimMat-Internal.html#t:FromPairs">FromPairs</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>