<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Numeric/Units/Dimensional/Extensible.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
Numeric.Dimensional.Extensible -- Extensible physical dimensions
Bjorn Buckwalter, bjorn.buckwalter@gmail.com
License: BSD3


= Summary =

On January 3 Mike Gunter asked[1]:

  The very nice Buckwalter and Denney dimensional-numbers packages
  both work on a fixed set of base dimensions.  This is a significant
  restriction for me--I want to avoid adding apples to oranges as
  well as avoiding adding meters to grams.  Is it possible to have
  an extensible set of base dimensions?  If so, how usable can such
  a system be made?  Is it very much worse than a system with a fixed
  set of base dimensions?

In this module we facilitate the addition an arbitrary number of
"extra" dimensions to the seven base dimensions defined in
'Numeric.Dimensional'. A quantity or unit with one or more extra
dimensions will be referred to as an "extended Dimensional".


= Preliminaries =

Similarly with 'Numeric.Dimensional' this module requires GHC
6.6 or later.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE UndecidableInstances
<a name="line-2"></a>&gt;            , ScopedTypeVariables
<a name="line-3"></a>&gt;            , EmptyDataDecls
<a name="line-4"></a>&gt;            , MultiParamTypeClasses
<a name="line-5"></a>&gt;            , FunctionalDependencies
<a name="line-6"></a>&gt;            , FlexibleInstances
<a name="line-7"></a>&gt; #-}</span>
</pre>
<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{- |
<a name="line-2"></a>&gt;    Copyright  : Copyright (C) 2006-2013 Bjorn Buckwalter
<a name="line-3"></a>&gt;    License    : BSD3
<a name="line-4"></a>&gt;
<a name="line-5"></a>&gt;    Maintainer : bjorn.buckwalter@gmail.com
<a name="line-6"></a>&gt;    Stability  : Experimental
<a name="line-7"></a>&gt;    Portability: GHC only?
<a name="line-8"></a>&gt;
<a name="line-9"></a>&gt; Please refer to the literate Haskell code for documentation of both API
<a name="line-10"></a>&gt; and implementation.
<a name="line-11"></a>&gt; -}</span>
</pre>
<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>Units</span><span class='hs-varop'>.</span><span class='hs-conid'>Dimensional</span><span class='hs-varop'>.</span><span class='hs-conid'>Extensible</span> <span class='hs-layout'>(</span> <span class='hs-conid'>DExt</span><span class='hs-layout'>,</span> <span class='hs-varid'>showDExt</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
</pre>
<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>Units</span><span class='hs-varop'>.</span><span class='hs-conid'>Dimensional</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Dim</span><span class='hs-layout'>,</span> <span class='hs-conid'>Mul</span><span class='hs-layout'>,</span> <span class='hs-conid'>Div</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pow</span><span class='hs-layout'>,</span> <span class='hs-conid'>Root</span><span class='hs-layout'>,</span> <span class='hs-varid'>dimUnit</span> <span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>NumType</span> <span class='hs-layout'>(</span> <span class='hs-conid'>NumType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Sum</span><span class='hs-layout'>,</span> <span class='hs-conid'>Negate</span><span class='hs-layout'>,</span> <span class='hs-conid'>Zero</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pos</span><span class='hs-layout'>,</span> <span class='hs-conid'>Neg</span> <span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>NumType</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>N</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Div</span><span class='hs-layout'>,</span> <span class='hs-conid'>Mul</span> <span class='hs-layout'>)</span>
</pre>

= 'DExt', 'Apples' and 'Oranges' =

We define the datatype 'DExt' which we will use to increase the
number of dimensions from the seven SI base dimensions to an arbitrary
number of dimensions.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span>
</pre>
The type variable 'a' is used to tag the extended dimensions with
an identity, thus preventing inadvertent mixing of extended dimensions.

Using 'DExt' we can define type synonyms for extended dimensions
applicable to our problem domain. For example, Mike Gunter could
define the 'Apples' and 'Oranges' dimensions and the corresponding
quantities.

] data TApples -- Type tag.
] type DApples  = DExt TApples Pos1 DOne
] type Apples   = Quantity DApples

] data TOrange -- Type tag.
] type DOranges = DExt TApples Zero (DExt TOranges Pos1 DOne)
] type Oranges  = Quantity DOranges

And while he was at it he could define corresponding units.

] apple  :: Num a => Unit DApples a
] apple  = Dimensional 1
] orange :: Num a => Unit DOranges a
] orange = Dimensional 1

When extending dimensions we adopt the convention that the first
(outermost) dimension is the reference for aligning dimensions, as
shown in the above example. This is important when performing
operations on two Dimensionals with a differing number of extended
dimensions.


= 'Show' helper function =

We provide a helper function to ease defining 'Show' instances.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>showDExt</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>NumType</span> <span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>showDExt</span> <span class='hs-varid'>u</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showHelp</span> <span class='hs-layout'>(</span><span class='hs-varid'>dimUnit</span> <span class='hs-varid'>u</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span>        <span class='hs-keyword'>where</span>
<a name="line-4"></a><span class='hs-varop'>&gt;</span>            <span class='hs-varid'>showHelp</span> <span class='hs-conid'>Nothing</span>   <span class='hs-varid'>s</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s</span>
<a name="line-5"></a><span class='hs-varop'>&gt;</span>            <span class='hs-varid'>showHelp</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>u'</span><span class='hs-layout'>)</span> <span class='hs-str'>""</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>u'</span>
<a name="line-6"></a><span class='hs-varop'>&gt;</span>            <span class='hs-varid'>showHelp</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>u'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>u'</span> <span class='hs-varop'>++</span> <span class='hs-str'>" "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>s</span>
</pre>
Using this helper function defining 'Show' instances for the dimensions
with extent in apples and oranges is simple.

] instance (NumType n, Show d) => Show (DExt TApples n d) where
]   show = showDExt "apple"
] instance (NumType n, Show d) => Show (DExt TOranges n d) where
]   show = showDExt "orange"


= The 'DropZero' class =

The choice of convention may seem backwards considering the opposite
convention is used for NumTypes (though for NumTypes the distinction
is arguably irrelevant). However, this choice facilitates relatively
simple interoperability with base dimensions. In particular it lets
us drop any dimensions with zero extent adjacent to the terminating
'Dim'. To capture this property we define the 'DropZero' class.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>class</span> <span class='hs-conid'>DropZero</span> <span class='hs-varid'>d</span> <span class='hs-varid'>d'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d'</span>
</pre>
The following 'DropZero' instances say that when an extended dimension
with zero extent is next to a 'Dim' the extended dimension can be
dropped. In all other cases the dimensions are retained as is.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>DropZero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Zero</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>j</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>DropZero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Zero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Zero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>DropZero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pos</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pos</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>DropZero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Neg</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Neg</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
</pre>

= Classes from 'Numeric.Dimensional' =

We get negation, addition and subtraction for free with extended
Dimensionals. However, we will need instances of the 'Mul', 'Div',
'Pow' and 'Root' classes for the corresponding operations to work.

Multiplication and division can cause dimensions to be eliminated.
We use the 'DropZero' type class to guarantee that the result of a
multiplication or division has a minimal representation.

When only one of the 'Mul' factors is an extended dimensional there is
no need to minimize.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mul</span> <span class='hs-varid'>d</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Mul</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mul</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Mul</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
</pre>
If both of the factors are extended the product must be minimized.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sum</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>n''</span><span class='hs-layout'>,</span> <span class='hs-conid'>Mul</span> <span class='hs-varid'>d</span> <span class='hs-varid'>d'</span> <span class='hs-varid'>d''</span><span class='hs-layout'>,</span> <span class='hs-conid'>DropZero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n''</span> <span class='hs-varid'>d''</span><span class='hs-layout'>)</span> <span class='hs-varid'>d'''</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Mul</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span> <span class='hs-varid'>d'''</span>
</pre>
Analogously for 'Div'.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Div</span> <span class='hs-varid'>d</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Div</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Div</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span> <span class='hs-varid'>d'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Negate</span> <span class='hs-varid'>x</span> <span class='hs-varid'>x'</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Div</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dim</span> <span class='hs-varid'>l</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span> <span class='hs-varid'>th</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x'</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sum</span> <span class='hs-varid'>n''</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-conid'>Div</span> <span class='hs-varid'>d</span> <span class='hs-varid'>d'</span> <span class='hs-varid'>d''</span><span class='hs-layout'>,</span> <span class='hs-conid'>DropZero</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n''</span> <span class='hs-varid'>d''</span><span class='hs-layout'>)</span> <span class='hs-varid'>d'''</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Div</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span> <span class='hs-varid'>d'''</span>
</pre>
The instances for 'Pow' and 'Root' are simpler since they can not
change any previously non-zero to be eliminated.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>N</span><span class='hs-varop'>.</span><span class='hs-conid'>Mul</span> <span class='hs-varid'>n</span> <span class='hs-varid'>x</span> <span class='hs-varid'>n'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pow</span> <span class='hs-varid'>d</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Pow</span>  <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>N</span><span class='hs-varop'>.</span><span class='hs-conid'>Div</span> <span class='hs-varid'>n</span> <span class='hs-varid'>x</span> <span class='hs-varid'>n'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Root</span>  <span class='hs-varid'>d</span> <span class='hs-varid'>x</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Root</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>DExt</span> <span class='hs-varid'>a</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
</pre>

= Note =

The use of 'DExt' is not particularily modular. Exrended dimensions
must adhere to a strict ordering in order to be compatible in terms
of e.g. multiplication. This makes it difficult to add extra
dimensions without full knowledge of all extra dimension one will
be interacting with.


= References =

[1] http://www.haskell.org/pipermail/haskell-cafe/2007-January/021069.html

</body>
</html>
